LETTER Communicated by Yann Le Cun
A Fast Learning Algorithm for Deep Belief Nets
Geoffrey E. Hinton
hinton@cs.toronto.edu
Simon Osindero
osindero@cs.toronto.edu
Department of Computer Science, University of Toronto, Toronto, Canada M5S 3G4
Yee-Whye Teh
tehyw@comp.nus.edu.sg
Department of Computer Science, National University of Singapore,
Singapore 117543
We show how to use “complementary priors” to eliminate the explainingaway effects that make inference difficult in densely connected belief nets
that have many hidden layers. Using complementary priors, we derive a
fast, greedy algorithm that can learn deep, directed belief networks one
layer at a time, provided the top two layers form an undirected associative memory. The fast, greedy algorithm is used to initialize a slower
learning procedure that fine-tunes the weights using a contrastive version of the wake-sleep algorithm. After fine-tuning, a network with three
hidden layers forms a very good generative model of the joint distribution of handwritten digit images and their labels. This generative model
gives better digit classification than the best discriminative learning algorithms. The low-dimensional manifolds on which the digits lie are
modeled by long ravines in the free-energy landscape of the top-level
associative memory, and it is easy to explore these ravines by using the
directed connections to display what the associative memory has in mind.
1 Introduction
Learning is difficult in densely connected, directed belief nets that have
many hidden layers because it is difficult to infer the conditional distribution of the hidden activities when given a data vector. Variational methods
use simple approximations to the true conditional distribution, but the approximations may be poor, especially at the deepest hidden layer, where
the prior assumes independence. Also, variational learning still requires all
of the parameters to be learned together and this makes the learning time
scale poorly as the number of parameters increases.
We describe a model in which the top two hidden layers form an undirected associative memory (see Figure 1) and the remaining hidden layers
Neural Computation 18, 1527–1554 (2006) C 2006 Massachusetts Institute of Technology1528 G. Hinton, S. Osindero, and Y.-W. Teh
2000 top-level units
500 units
500 units
28 x 28
pixel
image
10 label units
This could be the
top level of
another sensory
pathway
Figure 1: The network used to model the joint distribution of digit images and
digit labels. In this letter, each training case consists of an image and an explicit
class label, but work in progress has shown that the same learning algorithm
can be used if the “labels” are replaced by a multilayer pathway whose inputs
are spectrograms from multiple different speakers saying isolated digits. The
network then learns to generate pairs that consist of an image and a spectrogram
of the same digit class.
form a directed acyclic graph that converts the representations in the associative memory into observable variables such as the pixels of an image.
This hybrid model has some attractive features:
 There is a fast, greedy learning algorithm that can find a fairly good
set of parameters quickly, even in deep networks with millions of
parameters and many hidden layers.
 The learning algorithm is unsupervised but can be applied to labeled
data by learning a model that generates both the label and the data.
 There is a fine-tuning algorithm that learns an excellent generative model that outperforms discriminative methods on the MNIST
database of hand-written digits.
 The generative model makes it easy to interpret the distributed representations in the deep hidden layers.A Fast Learning Algorithm for Deep Belief Nets 1529
 The inference required for forming a percept is both fast and accurate.
 The learning algorithm is local. Adjustments to a synapse strength
depend on only the states of the presynaptic and postsynaptic neuron.
 The communication is simple. Neurons need only to communicate
their stochastic binary states.
Section 2 introduces the idea of a “complementary” prior that exactly
cancels the “explaining away” phenomenon that makes inference difficult
in directed models. An example of a directed belief network with complementary priors is presented. Section 3 shows the equivalence between
restricted Boltzmann machines and infinite directed networks with tied
weights.
Section 4 introduces a fast, greedy learning algorithm for constructing
multilayer directed networks one layer at a time. Using a variational bound,
it shows that as each new layer is added, the overall generative model
improves. The greedy algorithm bears some resemblance to boosting in
its repeated use of the same “weak” learner, but instead of reweighting
each data vector to ensure that the next step learns something new, it rerepresents it. The “weak” learner that is used to construct deep directed
nets is itself an undirected graphical model.
Section 5 shows how the weights produced by the fast, greedy algorithm can be fine-tuned using the “up-down” algorithm. This is a
contrastive version of the wake-sleep algorithm (Hinton, Dayan, Frey,
& Neal, 1995) that does not suffer from the “mode-averaging” problems that can cause the wake-sleep algorithm to learn poor recognition
weights.
Section 6 shows the pattern recognition performance of a network with
three hidden layers and about 1.7 million weights on the MNIST set of
handwritten digits. When no knowledge of geometry is provided and there
is no special preprocessing, the generalization performance of the network
is 1.25% errors on the 10,000-digit official test set. This beats the 1.5%
achieved by the best backpropagation nets when they are not handcrafted
for this particular application. It is also slightly better than the 1.4% errors
reported by Decoste and Schoelkopf (2002) for support vector machines on
the same task.
Finally, section 7 shows what happens in the mind of the network when
it is running without being constrained by visual input. The network has a
full generative model, so it is easy to look into its mind—we simply generate
an image from its high-level representations.
Throughout the letter, we consider nets composed of stochastic binary
variables, but the ideas can be generalized to other models in which the log
probability of a variable is an additive function of the states of its directly
connected neighbors (see appendix A for details).1530 G. Hinton, S. Osindero, and Y.-W. Teh
Figure 2: A simple logistic belief net containing two independent, rare causes
that become highly anticorrelated when we observe the house jumping. The bias
of -10 on the earthquake node means that in the absence of any observation,
this node is e10 times more likely to be off than on. If the earthquake node is on
and the truck node is off, the jump node has a total input of 0, which means
that it has an even chance of being on. This is a much better explanation of
the observation that the house jumped than the odds of e-20, which apply if
neither of the hidden causes is active. But it is wasteful to turn on both hidden
causes to explain the observation because the probability of both happening is
e-10 × e-10 = e-20. When the earthquake node is turned on, it “explains away”
the evidence for the truck node.
2 Complementary Priors
The phenomenon of explaining away (illustrated in Figure 2) makes inference difficult in directed belief nets. In densely connected networks, the
posterior distribution over the hidden variables is intractable except in a few
special cases, such as mixture models or linear models with additive gaussian noise. Markov chain Monte Carlo methods (Neal, 1992) can be used
to sample from the posterior, but they are typically very time-consuming.
Variational methods (Neal & Hinton, 1998) approximate the true posterior
with a more tractable distribution, and they can be used to improve a lower
bound on the log probability of the training data. It is comforting that learning is guaranteed to improve a variational bound even when the inference
of the hidden states is done incorrectly, but it would be much better to find
a way of eliminating explaining away altogether, even in models whose
hidden variables have highly correlated effects on the visible variables. It is
widely assumed that this is impossible.
A logistic belief net (Neal, 1992) is composed of stochastic binary units.
When the net is used to generate data, the probability of turning on unit i
is a logistic function of the states of its immediate ancestors, j, and of theA Fast Learning Algorithm for Deep Belief Nets 1531
weights, wi j, on the directed connections from the ancestors:
p(si = 1) = 1
1 + exp -bi -  j s jwi j, (2.1)
where bi is the bias of unit i. If a logistic belief net has only one hidden
layer, the prior distribution over the hidden variables is factorial because
their binary states are chosen independently when the model is used to
generate data. The nonindependence in the posterior distribution is created
by the likelihood term coming from the data. Perhaps we could eliminate
explaining away in the first hidden layer by using extra hidden layers to
create a “complementary” prior that has exactly the opposite correlations to
those in the likelihood term. Then, when the likelihood term is multiplied
by the prior, we will get a posterior that is exactly factorial. It is not at
all obvious that complementary priors exist, but Figure 3 shows a simple
example of an infinite logistic belief net with tied weights in which the priors
are complementary at every hidden layer (see appendixA for a more general
treatment of the conditions under which complementary priors exist). The
use of tied weights to construct complementary priors may seem like a mere
trick for making directed models equivalent to undirected ones. As we shall
see, however, it leads to a novel and very efficient learning algorithm that
works by progressively untying the weights in each layer from the weights
in higher layers.
2.1 An Infinite Directed Model with Tied Weights. We can generate
data from the infinite directed net in Figure 3 by starting with a random
configuration at an infinitely deep hidden layer1 and then performing a
top-down “ancestral” pass in which the binary state of each variable in a
layer is chosen from the Bernoulli distribution determined by the top-down
input coming from its active parents in the layer above. In this respect, it
is just like any other directed acyclic belief net. Unlike other directed nets,
however, we can sample from the true posterior distribution over all of the
hidden layers by starting with a data vector on the visible units and then
using the transposed weight matrices to infer the factorial distributions
over each hidden layer in turn. At each hidden layer, we sample from the
factorial posterior before computing the factorial posterior for the layer
above.2 Appendix A shows that this procedure gives unbiased samples
1 The generation process converges to the stationary distribution of the Markov chain,
so we need to start at a layer that is deep compared with the time it takes for the chain to
reach equilibrium.
2 This is exactly the same as the inference procedure used in the wake-sleep algorithm
(Hinton et al., 1995) but for the models described in this letter no variational approximation
is required because the inference procedure gives unbiased samples.1532 G. Hinton, S. Osindero, and Y.-W. Teh
W
V1
H1
V0
H0
V2
T
W TW W W
etc.
0i
v
0j
h
1j
2vi h 1vi
T
W
T
W
T
W W W
Figure 3: An infinite logistic belief net with tied weights. The downward arrows
represent the generative model. The upward arrows are not part of the model.
They represent the parameters that are used to infer samples from the posterior
distribution at each hidden layer of the net when a data vector is clamped
on V0.
because the complementary prior at each layer ensures that the posterior
distribution really is factorial.
Since we can sample from the true posterior, we can compute the derivatives of the log probability of the data. Let us start by computing the derivative for a generative weight, wi j 00, from a unit j in layer H0 to unit i in layer
V0 (see Figure 3). In a logistic belief net, the maximum likelihood learning
rule for a single data vector, v0, is
? log p(v0)
?w00
i j
= h0jvi0 - vˆi0, (2.2)
where · denotes an average over the sampled states and ˆ vi0 is the probability that unit i would be turned on if the visible vector was stochasticallyA Fast Learning Algorithm for Deep Belief Nets 1533
reconstructed from the sampled hidden states. Computing the posterior
distribution over the second hidden layer, V1, from the sampled binary
states in the first hidden layer, H0, is exactly the same process as reconstructing the data, so vi1 is a sample from a Bernoulli random variable with
probability ˆ vi0. The learning rule can therefore be written as
? log p(v0)
?w00
i j
= h0jvi0 - vi1. (2.3)
The dependence of vi1 on h0j is unproblematic in the derivation of equation
2.3 from equation 2.2 because ˆ vi0 is an expectation that is conditional on h0j.
Since the weights are replicated, the full derivative for a generative weight
is obtained by summing the derivatives of the generative weights between
all pairs of layers:
? log p(v0)
?wi j
= h0jvi0 - vi1 + vi1h0j - h1j + h1jvi1 - vi2 + · · · (2.4)
All of the pairwise products except the first and last cancel, leaving the
Boltzmann machine learning rule of equation 3.1.
3 Restricted Boltzmann Machines and Contrastive Divergence
Learning
It may not be immediately obvious that the infinite directed net in
Figure 3 is equivalent to a restricted Boltzmann machine (RBM). An RBM
has a single layer of hidden units that are not connected to each other and
have undirected, symmetrical connections to a layer of visible units. To
generate data from an RBM, we can start with a random state in one of
the layers and then perform alternating Gibbs sampling. All of the units
in one layer are updated in parallel given the current states of the units
in the other layer, and this is repeated until the system is sampling from
its equilibrium distribution. Notice that this is exactly the same process as
generating data from the infinite belief net with tied weights. To perform
maximum likelihood learning in an RBM, we can use the difference between two correlations. For each weight, wi j, between a visible unit i and
a hidden unit, j, we measure the correlation vi0h0j when a data vector is
clamped on the visible units and the hidden states are sampled from their
conditional distribution, which is factorial. Then, using alternating Gibbs
sampling, we run the Markov chain shown in Figure 4 until it reaches its
stationary distribution and measure the correlation vi8h8j . The gradient of
the log probability of the training data is then
? log p(v0)
?wi j
= vi0h0j - vi8h8j . (3.1)1534 G. Hinton, S. Osindero, and Y.-W. Teh
< 0 0>
vi h j
i
j
i
j
i
j
i
j
t = infinity
t = 0 t = 1 t = 2 t = infinity
< 8 8>
vi h j
Figure 4: This depicts a Markov chain that uses alternating Gibbs sampling.
In one full step of Gibbs sampling, the hidden units in the top layer are all
updated in parallel by applying equation 2.1 to the inputs received from the the
current states of the visible units in the bottom layer; then the visible units are
all updated in parallel given the current hidden states. The chain is initialized
by setting the binary states of the visible units to be the same as a data vector.
The correlations in the activities of a visible and a hidden unit are measured
after the first update of the hidden units and again at the end of the chain. The
difference of these two correlations provides the learning signal for updating
the weight on the connection.
This learning rule is the same as the maximum likelihood learning rule
for the infinite logistic belief net with tied weights, and each step of Gibbs
sampling corresponds to computing the exact posterior distribution in a
layer of the infinite logistic belief net.
Maximizing the log probability of the data is exactly the same as minimizing the Kullback-Leibler divergence, K L(P0||P?8), between the distribution
of the data, P0, and the equilibrium distribution defined by the model, P?8.
In contrastive divergence learning (Hinton, 2002), we run the Markov chain
for only n full steps before measuring the second correlation.3 This is equivalent to ignoring the derivatives that come from the higher layers of the
infinite net. The sum of all these ignored derivatives is the derivative of the
log probability of the posterior distribution in layer Vn, which is also the
derivative of the Kullback-Leibler divergence between the posterior distribution in layer Vn, P?n, and the equilibrium distribution defined by the
model. So contrastive divergence learning minimizes the difference of two
Kullback-Leibler divergences:
K LP0 P?8 - K LP?n P?8. (3.2)
Ignoring sampling noise, this difference is never negative because Gibbs
sampling is used to produce P?n from P0, and Gibbs sampling always reduces the Kullback-Leibler divergence with the equilibrium distribution. It
3 Each full step consists of updating h given v, then updating v given h.A Fast Learning Algorithm for Deep Belief Nets 1535
is important to notice that P?n depends on the current model parameters,
and the way in which P?n changes as the parameters change is being ignored by contrastive divergence learning. This problem does not arise with
P0 because the training data do not depend on the parameters. An empirical investigation of the relationship between the maximum likelihood and
the contrastive divergence learning rules can be found in Carreira-Perpinan
and Hinton (2005).
Contrastive divergence learning in a restricted Boltzmann machine is
efficient enough to be practical (Mayraz & Hinton, 2001). Variations that
use real-valued units and different sampling schemes are described in Teh,
Welling, Osindero, and Hinton (2003) and have been quite successful for
modeling the formation of topographic maps (Welling, Hinton, & Osindero,
2003) for denoising natural images (Roth & Black, 2005) or images of biological cells (Ning et al., 2005). Marks and Movellan (2001) describe a way
of using contrastive divergence to perform factor analysis and Welling,
Rosen-Zvi, and Hinton (2005) show that a network with logistic, binary
visible units and linear, gaussian hidden units can be used for rapid document retrieval. However, it appears that the efficiency has been bought
at a high price: When applied in the obvious way, contrastive divergence
learning fails for deep, multilayer networks with different weights at each
layer because these networks take far too long even to reach conditional
equilibrium with a clamped data vector. We now show that the equivalence
between RBMs and infinite directed nets with tied weights suggests an efficient learning algorithm for multilayer networks in which the weights are
not tied.
4 A Greedy Learning Algorithm for Transforming Representations
An efficient way to learn a complicated model is to combine a set of simpler
models that are learned sequentially. To force each model in the sequence to
learn something different from the previous models, the data are modified
in some way after each model has been learned. In boosting (Freund, 1995),
each model in the sequence is trained on reweighted data that emphasize
the cases that the preceding models got wrong. In one version of principal
components analysis, the variance in a modeled direction is removed, thus
forcing the next modeled direction to lie in the orthogonal subspace (Sanger,
1989). In projection pursuit (Friedman & Stuetzle, 1981), the data are transformed by nonlinearly distorting one direction in the data space to remove
all nongaussianity in that direction. The idea behind our greedy algorithm
is to allow each model in the sequence to receive a different representation
of the data. The model performs a nonlinear transformation on its input
vectors and produces as output the vectors that will be used as input for
the next model in the sequence.
Figure 5 shows a multilayer generative model in which the top two
layers interact via undirected connections and all of the other connections1536 G. Hinton, S. Osindero, and Y.-W. Teh
Figure 5: A hybrid network. The top two layers have undirected connections
and form an associative memory. The layers below have directed, top-down
generative connections that can be used to map a state of the associative memory
to an image. There are also directed, bottom-up recognition connections that are
used to infer a factorial representation in one layer from the binary activities in
the layer below. In the greedy initial learning, the recognition connections are
tied to the generative connections.
are directed. The undirected connections at the top are equivalent to having
infinitely many higher layers with tied weights. There are no intralayer
connections, and to simplify the analysis, all layers have the same number
of units. It is possible to learn sensible (though not optimal) values for the
parameters W0 by assuming that the parameters between higher layers will
be used to construct a complementary prior for W0. This is equivalent to
assuming that all of the weight matrices are constrained to be equal. The
task of learning W0 under this assumption reduces to the task of learning
an RBM, and although this is still difficult, good approximate solutions can
be found rapidly by minimizing contrastive divergence. Once W0 has been
learned, the data can be mapped through W0T to create higher-level “data”
at the first hidden layer.
If the RBM is a perfect model of the original data, the higher-level “data”
will already be modeled perfectly by the higher-level weight matrices. Generally, however, the RBM will not be able to model the original data perfectly,
and we can make the generative model better using the following greedy
algorithm:A Fast Learning Algorithm for Deep Belief Nets 1537
1. Learn W0 assuming all the weight matrices are tied.
2. Freeze W0 and commit ourselves to using W0T to infer factorial approximate posterior distributions over the states of the variables in the
first hidden layer, even if subsequent changes in higher-level weights
mean that this inference method is no longer correct.
3. Keeping all the higher-weight matrices tied to each other, but untied
from W0, learn an RBM model of the higher-level “data” that was
produced by using W0T to transform the original data.
If this greedy algorithm changes the higher-level weight matrices, it
is guaranteed to improve the generative model. As shown in Neal and
Hinton (1998), the negative log probability of a single data vector, v0, under
the multilayer generative model is bounded by a variational free energy, which is the expected energy under the approximating distribution,
Q(h0|v0), minus the entropy of that distribution. For a directed model, the
“energy” of the configuration v0, h0 is given by
E(v0, h0) = -[log p(h0) + log p(v0|h0)], (4.1)
so the bound is
log p(v0) = 
all h0
Q(h0|v0)[log p(h0) + log p(v0|h0)]
- 
all h0
Q(h0|v0) log Q(h0|v0), (4.2)
where h0 is a binary configuration of the units in the first hidden layer, p(h0)
is the prior probability of h0 under the current model (which is defined by
the weights above H0), and Q(·|v0) is any probability distribution over
the binary configurations in the first hidden layer. The bound becomes an
equality if and only if Q(·|v0) is the true posterior distribution.
When all of the weight matrices are tied together, the factorial distribution over H0 produced by applying W0T to a data vector is the true posterior
distribution, so at step 2 of the greedy algorithm, log p(v0) is equal to the
bound. Step 2 freezes both Q(·|v0) and p(v0|h0), and with these terms fixed,
the derivative of the bound is the same as the derivative of

all h0
Q(h0|v0) log p(h0). (4.3)
So maximizing the bound with respect to the weights in the higher layers
is exactly equivalent to maximizing the log probability of a data set in
which h0 occurs with probability Q(h0|v0). If the bound becomes tighter, it1538 G. Hinton, S. Osindero, and Y.-W. Teh
is possible for log p(v0) to fall even though the lower bound on it increases,
but log p(v0) can never fall below its value at step 2 of the greedy algorithm
because the bound is tight at this point and the bound always increases.
The greedy algorithm can clearly be applied recursively, so if we use the
full maximum likelihood Boltzmann machine learning algorithm to learn
each set of tied weights and then we untie the bottom layer of the set from
the weights above, we can learn the weights one layer at a time with a
guarantee that we will never decrease the bound on the log probability of
the data under the model.4 In practice, we replace the maximum likelihood
Boltzmann machine learning algorithm by contrastive divergence learning
because it works well and is much faster. The use of contrastive divergence
voids the guarantee, but it is still reassuring to know that extra layers
are guaranteed to improve imperfect models if we learn each layer with
sufficient patience.
To guarantee that the generative model is improved by greedily learning
more layers, it is convenient to consider models in which all layers are the
same size so that the higher-level weights can be initialized to the values
learned before they are untied from the weights in the layer below. The
same greedy algorithm, however, can be applied even when the layers are
different sizes.
5 Back-Fitting with the Up-Down Algorithm
Learning the weight matrices one layer at a time is efficient but not optimal.
Once the weights in higher layers have been learned, neither the weights
nor the simple inference procedure are optimal for the lower layers. The
suboptimality produced by greedy learning is relatively innocuous for supervised methods like boosting. Labels are often scarce, and each label may
provide only a few bits of constraint on the parameters, so overfitting is
typically more of a problem than underfitting. Going back and refitting the
earlier models may therefore cause more harm than good. Unsupervised
methods, however, can use very large unlabeled data sets, and each case
may be very high-dimensional, thus providing many bits of constraint on
a generative model. Underfitting is then a serious problem, which can be
alleviated by a subsequent stage of back-fitting in which the weights that
were learned first are revised to fit in better with the weights that were
learned later.
After greedily learning good initial values for the weights in every layer,
we untie the “recognition” weights that are used for inference from the
“generative” weights that define the model, but retain the restriction that
the posterior in each layer must be approximated by a factorial distribution
in which the variables within a layer are conditionally independent given
4 The guarantee is on the expected change in the bound.A Fast Learning Algorithm for Deep Belief Nets 1539
the values of the variables in the layer below. A variant of the wake-sleep
algorithm described in Hinton et al. (1995) can then be used to allow the
higher-level weights to influence the lower-level ones. In the “up-pass,” the
recognition weights are used in a bottom-up pass that stochastically picks
a state for every hidden variable. The generative weights on the directed
connections are then adjusted using the maximum likelihood learning rule
in equation 2.2.5 The weights on the undirected connections at the top
level are learned as before by fitting the top-level RBM to the posterior
distribution of the penultimate layer.
The “down-pass” starts with a state of the top-level associative memory and uses the top-down generative connections to stochastically activate
each lower layer in turn. During the down-pass, the top-level undirected
connections and the generative directed connections are not changed. Only
the bottom-up recognition weights are modified. This is equivalent to the
sleep phase of the wake-sleep algorithm if the associative memory is allowed to settle to its equilibrium distribution before initiating the downpass. But if the associative memory is initialized by an up-pass and then
only allowed to run for a few iterations of alternating Gibbs sampling before initiating the down-pass, this is a “contrastive” form of the wake-sleep
algorithm that eliminates the need to sample from the equilibrium distribution of the associative memory. The contrastive form also fixes several
other problems of the sleep phase. It ensures that the recognition weights
are being learned for representations that resemble those used for real data,
and it also helps to eliminate the problem of mode averaging. If, given a
particular data vector, the current recognition weights always pick a particular mode at the level above and ignore other very different modes that are
equally good at generating the data, the learning in the down-pass will not
try to alter those recognition weights to recover any of the other modes as it
would if the sleep phase used a pure ancestral pass. A pure ancestral pass
would have to start by using prolonged Gibbs sampling to get an equilibrium sample from the top-level associative memory. By using a top-level
associative memory, we also eliminate a problem in the wake phase: independent top-level units seem to be required to allow an ancestral pass, but
they mean that the variational approximation is very poor for the top layer
of weights.
Appendix B specifies the details of the up-down algorithm using
MATLAB-style pseudocode for the network shown in Figure 1. For simplicity, there is no penalty on the weights, no momentum, and the same
learning rate for all parameters. Also, the training data are reduced to a
single case.
5 Because weights are no longer tied to the weights above them, ˆ vi0 must be computed
using the states of the variables in the layer above i and the generative weights from these
variables to i.1540 G. Hinton, S. Osindero, and Y.-W. Teh
6 Performance on the MNIST Database
6.1 Training the Network. The MNIST database of handwritten digits
contains 60,000 training images and 10,000 test images. Results for many
different pattern recognition techniques are already published for this publicly available database, so it is ideal for evaluating new pattern recognition
methods. For the basic version of the MNIST learning task, no knowledge
of geometry is provided, and there is no special preprocessing or enhancement of the training set, so an unknown but fixed random permutation of
the pixels would not affect the learning algorithm. For this “permutationinvariant” version of the task, the generalization performance of our network was 1.25% errors on the official test set. The network shown in
Figure 1 was trained on 44,000 of the training images that were divided
into 440 balanced mini-batches, each containing 10 examples of each digit
class.6 The weights were updated after each mini-batch.
In the initial phase of training, the greedy algorithm described in section 4
was used to train each layer of weights separately, starting at the bottom. Each layer was trained for 30 sweeps through the training set (called
“epochs”). During training, the units in the “visible” layer of each RBM
had real-valued activities between 0 and 1. These were the normalized
pixel intensities when learning the bottom layer of weights. For training
higher layers of weights, the real-valued activities of the visible units in the
RBM were the activation probabilities of the hidden units in the lower-level
RBM. The hidden layer of each RBM used stochastic binary values when
that RBM was being trained. The greedy training took a few hours per layer
in MATLAB on a 3 GHz Xeon processor, and when it was done, the error
rate on the test set was 2.49% (see below for details of how the network is
tested).
When training the top layer of weights (the ones in the associative memory), the labels were provided as part of the input. The labels were represented by turning on one unit in a “softmax” group of 10 units. When the
activities in this group were reconstructed from the activities in the layer
above, exactly one unit was allowed to be active, and the probability of
picking unit i was given by
pi =
exp(xi)
 j exp(xj), (6.1)
where xi is the total input received by unit i. Curiously, the learning rules
are unaffected by the competition between units in a softmax group, so the
6 Preliminary experiments with 16 × 16 images of handwritten digits from the USPS
database showed that a good way to model the joint distribution of digit images and their
labels was to use an architecture of this type, but for 16 × 16 images, only three-fifths as
many units were used in each hidden layer.A Fast Learning Algorithm for Deep Belief Nets 1541
synapses do not need to know which unit is competing with which other
unit. The competition affects the probability of a unit turning on, but it is
only this probability that affects the learning.
After the greedy layer-by-layer training, the network was trained, with a
different learning rate and weight decay, for 300 epochs using the up-down
algorithm described in section 5. The learning rate, momentum, and weight
decay7 were chosen by training the network several times and observing its
performance on a separate validation set of 10,000 images that were taken
from the remainder of the full training set. For the first 100 epochs of the
up-down algorithm, the up-pass was followed by three full iterations of
alternating Gibbs sampling in the associative memory before performing
the down-pass. For the second 100 epochs, 6 iterations were performed, and
for the last 100 epochs, 10 iterations were performed. Each time the number
of iterations of Gibbs sampling was raised, the error on the validation set
decreased noticeably.
The network that performed best on the validation set was tested and
had an error rate of 1.39%. This network was then trained on all 60,000
training images8 until its error rate on the full training set was as low as
its final error rate had been on the initial training set of 44,000 images. This
took a further 59 epochs, making the total learning time about a week. The
final network had an error rate of 1.25%.9 The errors made by the network
are shown in Figure 6. The 49 cases that the network gets correct but for
which the second-best probability is within 0.3 of the best probability are
shown in Figure 7.
The error rate of 1.25% compares very favorably with the error rates
achieved by feedforward neural networks that have one or two hidden layers and are trained to optimize discrimination using the backpropagation
algorithm (see Table 1). When the detailed connectivity of these networks
is not handcrafted for this particular task, the best reported error rate for
stochastic online learning with a separate squared error on each of the 10
output units is 2.95%. These error rates can be reduced to 1.53% in a net
with one hidden layer of 800 units by using small initial weights, a separate
cross-entropy error function on each output unit, and very gentle learning
7 No attempt was made to use different learning rates or weight decays for different
layers, and the learning rate and momentum were always set quite conservatively to avoid
oscillations. It is highly likely that the learning speed could be considerably improved by
a more careful choice of learning parameters, though it is possible that this would lead to
worse solutions.
8 The training set has unequal numbers of each class, so images were assigned randomly to each of the 600 mini-batches.
9 To check that further learning would not have significantly improved the error rate,
the network was then left running with a very small learning rate and with the test error
being displayed after every epoch. After six weeks, the test error was fluctuating between
1.12% and 1.31% and was 1.18% for the epoch on which number of training errors was
smallest.1542 G. Hinton, S. Osindero, and Y.-W. Teh
Figure 6: The 125 test cases that the network got wrong. Each case is labeled by
the network’s guess. The true classes are arranged in standard scan order.
(John Platt, personal communication, 2005). An almost identical result of
1.51% was achieved in a net that had 500 units in the first hidden layer and
300 in the second hidden layer by using “softmax” output units and a regularizer that penalizes the squared weights by an amount carefully chosen
using a validation set. For comparison, nearest neighbor has a reported error
rate (http://oldmill.uchicago.edu/wilder/Mnist/) of 3.1% if all 60,000
training cases are used (which is extremely slow) and 4.4% if 20,000 are
used. This can be reduced to 2.8% and 4.0% by using an L3 norm.
The only standard machine learning technique that comes close to the
1.25% error rate of our generative model on the basic task is a support vector
machine that gives an error rate of 1.4% (Decoste & Schoelkopf, 2002). But
it is hard to see how support vector machines can make use of the domainspecific tricks, like weight sharing and subsampling, which LeCun, Bottou,
and Haffner (1998) use to improve the performance of discriminativeA Fast Learning Algorithm for Deep Belief Nets 1543
Figure 7: All 49 cases in which the network guessed right but had a second
guess whose probability was within 0.3 of the probability of the best guess. The
true classes are arranged in standard scan order.
neural networks from 1.5% to 0.95%. There is no obvious reason why weight
sharing and subsampling cannot be used to reduce the error rate of the generative model, and we are currently investigating this approach. Further
improvements can always be achieved by averaging the opinions of multiple networks, but this technique is available to all methods.
Substantial reductions in the error rate can be achieved by supplementing the data set with slightly transformed versions of the training data. Using one- and two-pixel translations, Decoste and Schoelkopf (2002) achieve
0.56%. Using local elastic deformations in a convolutional neural network,
Simard, Steinkraus, and Platt (2003) achieve 0.4%, which is slightly better than the 0.63% achieved by the best hand-coded recognition algorithm
(Belongie, Malik, & Puzicha, 2002). We have not yet explored the use of
distorted data for learning generative models because many types of distortion need to be investigated, and the fine-tuning algorithm is currently
too slow.
6.2 Testing the Network. One way to test the network is to use a
stochastic up-pass from the image to fix the binary states of the 500 units in
the lower layer of the associative memory. With these states fixed, the label
units are given initial real-valued activities of 0.1, and a few iterations of
alternating Gibbs sampling are then used to activate the correct label unit.
This method of testing gives error rates that are almost 1% higher than the
rates reported above.1544 G. Hinton, S. Osindero, and Y.-W. Teh
Table 1: Error rates of Various Learning Algorithms on the MNIST Digit Recognition Task.
Version of MNIST Task Learning Algorithm Test Error %
Permutation invariant Our generative model:
784 ? 500 ? 500 ? 2000 ? 10
1.25
Permutation invariant Support vector machine: degree 9
polynomial kernel
1.4
Permutation invariant Backprop: 784 ? 500 ? 300 ? 10
cross-entropy and weight-decay
1.51
Permutation invariant Backprop: 784 ? 800 ? 10
cross-entropy and early stopping
1.53
Permutation invariant Backprop: 784 ? 500 ? 150 ? 10
squared error and on-line updates
2.95
Permutation invariant Nearest neighbor: all 60,000 examples
and L3 norm
2.8
Permutation invariant Nearest neighbor: all 60,000 examples
and L2 norm
3.1
Permutation invariant Nearest neighbor: 20,000 examples and
L3 norm
4.0
Permutation invariant Nearest neighbor: 20,000 examples and
L2 norm
4.4
Unpermuted images; extra Backprop: cross-entropy and 0.4
data from elastic early-stopping convolutional neural net
deformations
Unpermuted de-skewed Virtual SVM: degree 9 polynomial 0.56
images; extra data from 2 kernel
pixel translations
Unpermuted images Shape-context features: hand-coded
matching
0.63
Unpermuted images; extra Backprop in LeNet5: convolutional 0.8
data from affine neural net
transformations
Unpermuted images Backprop in LeNet5: convolutional
neural net
0.95
A better method is to first fix the binary states of the 500 units in the
lower layer of the associative memory and to then turn on each of the
label units in turn and compute the exact free energy of the resulting
510-component binary vector. Almost all the computation required is independent of which label unit is turned on (Teh & Hinton, 2001), and this
method computes the exact conditional equilibrium distribution over labels
instead of approximating it by Gibbs sampling, which is what the previous method is doing. This method gives error rates that are about 0.5%
higher than the ones quoted because of the stochastic decisions made in
the up-pass. We can remove this noise in two ways. The simpler is to make
the up-pass deterministic by using probabilities of activation in place ofA Fast Learning Algorithm for Deep Belief Nets 1545
Figure 8: Each row shows 10 samples from the generative model with a particular label clamped on. The top-level associative memory is run for 1000 iterations
of alternating Gibbs sampling between samples.
stochastic binary states. The second is to repeat the stochastic up-pass
20 times and average either the label probabilities or the label log probabilities over the 20 repetitions before picking the best one. The two types
of average give almost identical results, and these results are also very similar to using a single deterministic up-pass, which was the method used for
the reported results.
7 Looking into the Mind of a Neural Network
To generate samples from the model, we perform alternating Gibbs sampling in the top-level associative memory until the Markov chain converges
to the equilibrium distribution. Then we use a sample from this distribution
as input to the layers below and generate an image by a single down-pass
through the generative connections. If we clamp the label units to a particular class during the Gibbs sampling, we can see images from the model’s
class-conditional distributions. Figure 8 shows a sequence of images for
each class that were generated by allowing 1000 iterations of Gibbs sampling between samples.
We can also initialize the state of the top two layers by providing a
random binary image as input. Figure 9 shows how the class-conditional
state of the associative memory then evolves when it is allowed to run freely,
but with the label clamped. This internal state is “observed” by performing
a down-pass every 20 iterations to see what the associative memory has1546 G. Hinton, S. Osindero, and Y.-W. Teh
Figure 9: Each row shows 10 samples from the generative model with a particular label clamped on. The top-level associative memory is initialized by an
up-pass from a random binary image in which each pixel is on with a probability
of 0.5. The first column shows the results of a down-pass from this initial highlevel state. Subsequent columns are produced by 20 iterations of alternating
Gibbs sampling in the associative memory.
in mind. This use of the word mind is not intended to be metaphorical.
We believe that a mental state is the state of a hypothetical, external world
in which a high-level internal representation would constitute veridical
perception. That hypothetical world is what the figure shows.
8 Conclusion
We have shown that it is possible to learn a deep, densely connected belief network one layer at a time. The obvious way to do this is to assume
that the higher layers do not exist when learning the lower layers, but
this is not compatible with the use of simple factorial approximations to
replace the intractable posterior distribution. For these approximations to
work well, we need the true posterior to be as close to factorial as possible. So instead of ignoring the higher layers, we assume that they exist
but have tied weights that are constrained to implement a complementary
prior that makes the true posterior exactly factorial. This is equivalent to
having an undirected model that can be learned efficiently using contrastive
divergence. It can also be viewed as constrained variational learning because a penalty term—the divergence between the approximate and trueA Fast Learning Algorithm for Deep Belief Nets 1547
posteriors—has been replaced by the constraint that the prior must make
the variational approximation exact.
After each layer has been learned, its weights are untied from the weights
in higher layers. As these higher-level weights change, the priors for lower
layers cease to be complementary, so the true posterior distributions in
lower layers are no longer factorial, and the use of the transpose of the
generative weights for inference is no longer correct. Nevertheless, we can
use a variational bound to show that adapting the higher-level weights
improves the overall generative model.
To demonstrate the power of our fast, greedy learning algorithm, we
used it to initialize the weights for a much slower fine-tuning algorithm
that learns an excellent generative model of digit images and their labels. It
is not clear that this is the best way to use the fast, greedy algorithm. It might
be better to omit the fine-tuning and use the speed of the greedy algorithm
to learn an ensemble of larger, deeper networks or a much larger training
set. The network in Figure 1 has about as many parameters as 0.002 cubic
millimeters of mouse cortex (Horace Barlow, personal communication,
1999), and several hundred networks of this complexity could fit within
a single voxel of a high-resolution fMRI scan. This suggests that much bigger networks may be required to compete with human shape recognition
abilities.
Our current generative model is limited in many ways (Lee & Mumford,
2003). It is designed for images in which nonbinary values can be treated as
probabilities (which is not the case for natural images); its use of top-down
feedback during perception is limited to the associative memory in the top
two layers; it does not have a systematic way of dealing with perceptual
invariances; it assumes that segmentation has already been performed; and
it does not learn to sequentially attend to the most informative parts of
objects when discrimination is difficult. It does, however, illustrate some of
the major advantages of generative models as compared to discriminative
ones:
 Generative models can learn low-level features without requiring feedback from the label, and they can learn many more
parameters than discriminative models without overfitting. In discriminative learning, each training case constrains the parameters
only by as many bits of information as are required to specify
the label. For a generative model, each training case constrains
the parameters by the number of bits required to specify the
input.
 It is easy to see what the network has learned by generating from its
model.
 It is possible to interpret the nonlinear, distributed representations in
the deep hidden layers by generating images from them.1548 G. Hinton, S. Osindero, and Y.-W. Teh
 The superior classification performance of discriminative learning
methods holds only for domains in which it is not possible to learn
a good generative model. This set of domains is being eroded by
Moore’s law.
Appendix A: Complementary Priors
A.1 General Complementarity. Consider a joint distribution over observables, x, and hidden variables, y. For a given likelihood function, P(x|y),
we define the corresponding family of complementary priors to be those
distributions, P(y), for which the joint distribution, P(x, y) = P(x|y)P(y),
leads to posteriors, P(y|x), that exactly factorize, that is, leads to a posterior
that can be expressed as P(y|x) =  j P(yj|x).
Not all functional forms of likelihood admit a complementary prior. In
this appendix, we show that the following family constitutes all likelihood
functions admitting a complementary prior,
P(x|y) = 1
(y) exp 
j
 j(x, yj) + ß(x)
= exp 
j
 j(x, yj) + ß(x) - log (y) , (A.1)
where  is the normalization term. For this assertion to hold, we need to
assume positivity of distributions: that both P(y) > 0 and P(x|y) > 0 for
every value of y and x. The corresponding family of complementary priors
then assumes the form
P(y) = 1
C
exp log (y) + 
j
a j(yj) , (A.2)
where C is a constant to ensure normalization. This combination of functional forms leads to the following expression for the joint,
P(x, y) = 1
C
exp 
j
 j(x, yj) + ß(x) + 
j
a j(yj) . (A.3)
To prove our assertion, we need to show that every likelihood function of form equation A.1 admits a complementary prior and vice versa.
First, it can be directly verified that equation A.2 is a complementary prior
for the likelihood functions of equation A.1. To show the converse, let us
assume that P(y) is a complementary prior for some likelihood function
P(x|y). Notice that the factorial form of the posterior simply means that theA Fast Learning Algorithm for Deep Belief Nets 1549
joint distribution P(x, y) = P(y)P(x|y) satisfies the following set of conditional independencies: yj ?? yk | x for every j = k. This set of conditional
independencies corresponds exactly to the relations satisfied by an undirected graphical model having edges between every hidden and observed
variable and among all observed variables. By the Hammersley-Clifford
theorem and using our positivity assumption, the joint distribution must
be of the form of equation A.3, and the forms for the likelihood function
equation A.1 and prior equation A.2 follow from this.
A.2 Complementarity for Infinite Stacks. We now consider a subset of
models of the form in equation A.3 for which the likelihood also factorizes.
This means that we now have two sets of conditional independencies:
P(x|y) =
i
P(xi|y) (A.4)
P(y|x) =
j
P(yj|x). (A.5)
This condition is useful for our construction of the infinite stack of directed
graphical models.
Identifying the conditional independencies in equations A.4 and A.5
as those satisfied by a complete bipartite undirected graphical model, and
again using the Hammersley-Clifford theorem (assuming positivity), we see
that the following form fully characterizes all joint distributions of interest,
P(x, y) = 1
Z
exp 
i, j
i, j(xi, yj) + 
i
?i(xi) + 
j
a j(yj) , (A.6)
while the likelihood functions take on the form
P(x|y) = exp 
i, j
i, j(xi, yj) + 
i
?i(xi) - log (y) . (A.7)
Although it is not immediately obvious, the marginal distribution over
the observables, x, in equation A.6 can also be expressed as an infinite
directed model in which the parameters defining the conditional distributions between layers are tied together.
An intuitive way of validating this assertion is as follows. Consider one of
the methods by which we might draw samples from the marginal distribution P(x) implied by equation A.6. Starting from an arbitrary configuration
of y, we would iteratively perform Gibbs sampling using, in alternation,
the distributions given in equations A.4 and A.5. If we run this Markov
chain for long enough, then, under the mild assumption that the chain1550 G. Hinton, S. Osindero, and Y.-W. Teh
mixes properly, we will eventually obtain unbiased samples from the joint
distribution given in equation A.6.
Now let us imagine that we unroll this sequence of Gibbs updates in
space, such that we consider each parallel update of the variables to constitute states of a separate layer in a graph. This unrolled sequence of states has
a purely directed structure (with conditional distributions taking the form
of equations A.4 and A.5 and in alternation). By equivalence to the Gibbs
sampling scheme, after many layers in such an unrolled graph, adjacent
pairs of layers will have a joint distribution as given in equation A.6.
We can formalize the above intuition for unrolling the graph as follows.
The basic idea is to unroll the graph “upwards” (i.e., moving away from the
data), so that we can put a well-defined distribution over the infinite stack of
variables. Then we verify some simple marginal and conditional properties
of the joint distribution and thus demonstrate the required properties of the
graph in the “downwards” direction.
Let x = x(0), y = y(0), x(1), y(1), x(2), y(2), . . . be a sequence (stack) of variables, the first two of which are identified as our original observed and
hidden variable. Define the functions
f (x , y ) = 1
Z
exp 
i, j
i, j(xi, yi) + 
i
?i(xi) + 
j
a j(yj) (A.8)
fx(x ) =
y
f (x , y ) (A.9)
fy
(y ) =
x
f (x , y ) (A.10)
gx(x |y ) = f (x , y )/fy(y ) (A.11)
gy(y |x ) = f (x , y )/fx(x ), (A.12)
and define a joint distribution over our sequence of variables as follows:
P(x(0), y(0)) = fx(0), y(0) (A.13)
P(x(i)|y(i-1)) = gxx(i)|y(i-1) i = 1, 2, . . . (A.14)
P(y(i)|x(i)) = gyy(i)|x(i). i = 1, 2, . . . (A.15)
We verify by induction that the distribution has the following marginal
distributions:
P(x(i)) = fxx(i) i = 0, 1, 2, . . . (A.16)
P(y(i)) = fyy(i) i = 0, 1, 2, . . . (A.17)A Fast Learning Algorithm for Deep Belief Nets 1551
For i = 0 this is given by definition of the distribution in equation A.13. For
i > 0, we have:
P(x(i)) = 
y(i-1)
Px(i)|y(i-1)Py(i-1) = 
y(i-1)
fx(i), y(i-1)
fy
y(i-1) fyy(i-1)
= fxx(i) (A.18)
and similarly for P(y(i)). Now we see that the following conditional distributions also hold true:
Px(i)|y(i)= Px(i), y(i)Py(i) = gxx(i)|y(i) (A.19)
Py(i)|x(i+1)= Py(i), x(i+1)Px(i+1) = gyy(i)|x(i+1). (A.20)
So our joint distribution over the stack of variables also leads to the appropriate conditional distributions for the unrolled graph in the “downwards”
direction. Inference in this infinite graph is equivalent to inference in the
joint distribution over the sequence of variables, that is, given x(0), we can
obtain a sample from the posterior simply by sampling y(0)|x(0), x(1)|y(0),
y(1)|x(1), . . . . This directly shows that our inference procedure is exact for
the unrolled graph.
Appendix B: Pseudocode for Up-Down Algorithm
We now present MATLAB-style pseudocode for an implementation of the
up-down algorithm described in section 5 and used for back-fitting. (This
method is a contrastive version of the wake-sleep algorithm; Hinton et al.,
1995.)
The code outlined below assumes a network of the type shown in
Figure 1 with visible inputs, label nodes, and three layers of hidden units.
Before applying the up-down algorithm, we would first perform layer-wise
greedy training as described in sections 3 and 4.
\% UP-DOWN ALGORITHM
\%
\% the data and all biases are row vectors.
\% the generative model is: lab <--> top <--> pen --> hid --> vis
\% the number of units in layer foo is numfoo
\% weight matrices have names fromlayer tolayer
\% "rec" is for recognition biases and "gen" is for generative
\% biases.
\% for simplicity, the same learning rate, r, is used everywhere.1552 G. Hinton, S. Osindero, and Y.-W. Teh
\% PERFORM A BOTTOM-UP PASS TO GET WAKE/POSITIVE PHASE
\% PROBABILITIES AND SAMPLE STATES
wakehidprobs = logistic(data*vishid + hidrecbiases);
wakehidstates = wakehidprobs > rand(1, numhid);
wakepenprobs = logistic(wakehidstates*hidpen + penrecbiases);
wakepenstates = wakepenprobs > rand(1, numpen);
wakeopprobs = logistic(wakepenstates*pentop + targets*labtop +
topbiases);
wakeopstates = wakeopprobs > rand(1, numtop);
\% POSITIVE PHASE STATISTICS FOR CONTRASTIVE DIVERGENCE
poslabtopstatistics = targets’ * waketopstates;
pospentopstatistics = wakepenstates’ * waketopstates;
\% PERFORM numCDiters GIBBS SAMPLING ITERATIONS USING THE TOP LEVEL
\% UNDIRECTED ASSOCIATIVE MEMORY
negtopstates = waketopstates; \% to initialize loop
for iter=1:numCDiters
negpenprobs = logistic(negtopstates*pentop’ + pengenbiases);
negpenstates = negpenprobs > rand(1, numpen);
neglabprobs = softmax(negtopstates*labtop’ + labgenbiases);
negtopprobs = logistic(negpenstates*pentop+neglabprobs*labtop+
topbiases);
negtopstates = negtopprobs > rand(1, numtop));
end;
\% NEGATIVE PHASE STATISTICS FOR CONTRASTIVE DIVERGENCE
negpentopstatistics = negpenstates’*negtopstates;
neglabtopstatistics = neglabprobs’*negtopstates;
\% STARTING FROM THE END OF THE GIBBS SAMPLING RUN, PERFORM A
\% TOP-DOWN GENERATIVE PASS TO GET SLEEP/NEGATIVE PHASE
\% PROBABILITIES AND SAMPLE STATES
sleeppenstates = negpenstates;
sleephidprobs = logistic(sleeppenstates*penhid + hidgenbiases);
sleephidstates = sleephidprobs > rand(1, numhid);
sleepvisprobs = logistic(sleephidstates*hidvis + visgenbiases);
\% PREDICTIONS
psleeppenstates = logistic(sleephidstates*hidpen + penrecbiases);
psleephidstates = logistic(sleepvisprobs*vishid + hidrecbiases);
pvisprobs = logistic(wakehidstates*hidvis + visgenbiases);
phidprobs = logistic(wakepenstates*penhid + hidgenbiases);
\% UPDATES TO GENERATIVE PARAMETERS
hidvis = hidvis + r*poshidstates’*(data-pvisprobs);A Fast Learning Algorithm for Deep Belief Nets 1553
visgenbiases = visgenbiases + r*(data - pvisprobs);
penhid = penhid + r*wakepenstates’*(wakehidstates-phidprobs);
hidgenbiases = hidgenbiases + r*(wakehidstates - phidprobs);
\% UPDATES TO TOP LEVEL ASSOCIATIVE MEMORY PARAMETERS
labtop = labtop + r*(poslabtopstatistics-neglabtopstatistics);
labgenbiases = labgenbiases + r*(targets - neglabprobs);
pentop = pentop + r*(pospentopstatistics - negpentopstatistics);
pengenbiases = pengenbiases + r*(wakepenstates - negpenstates);
topbiases = topbiases + r*(waketopstates - negtopstates);
\%UPDATES TO RECOGNITION/INFERENCE APPROXIMATION PARAMETERS
hidpen = hidpen + r*(sleephidstates’*(sleeppenstatespsleeppenstates));
penrecbiases = penrecbiases + r*(sleeppenstates-psleeppenstates);
vishid = vishid + r*(sleepvisprobs’*(sleephidstatespsleephidstates));
hidrecbiases = hidrecbiases + r*(sleephidstates-psleephidstates);
Acknowledgments
We thank Peter Dayan, Zoubin Ghahramani, Yann Le Cun, Andriy Mnih,
Radford Neal, Terry Sejnowski, and Max Welling for helpful discussions
and the referees for greatly improving the manuscript. The research was
supported by NSERC, the Gatsby Charitable Foundation, CFI, and OIT.
G.E.H. is a fellow of the Canadian Institute for Advanced Research and
holds a Canada Research Chair in machine learning.
References
Belongie, S., Malik, J., & Puzicha, J. (2002). Shape matching and object recognition
using shape contexts. IEEE Transactions on Pattern Analysis and Machine Intelligence, 24(4), 509–522.
Carreira-Perpinan, M. A., & Hinton, G. E. (2005). On contrastive divergence learning. In R. G. Cowell & Z. Ghahramani (Eds.), Artificial Intelligence and Statistics,
2005. (pp. 33–41). Fort Lauderdale, FL: Society for Artificial Intelligence and
Statistics.
Decoste, D., & Schoelkopf, B. (2002). Training invariant support vector machines,
Machine Learning, 46, 161–190.
Freund, Y. (1995). Boosting a weak learning algorithm by majority. Information and
Computation, 12(2), 256–285.
Friedman, J., & Stuetzle, W. (1981). Projection pursuit regression. Journal of the American Statistical Association, 76, 817–823.
Hinton, G. E. (2002). Training products of experts by minimizing contrastive divergence, Neural Computation, 14(8), 1711–1800.1554 G. Hinton, S. Osindero, and Y.-W. Teh
Hinton, G. E., Dayan, P., Frey, B. J., & Neal, R. (1995). The wake-sleep algorithm for
self-organizing neural networks. Science, 268, 1158–1161.
LeCun, Y., Bottou, L., & Haffner, P. (1998). Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11), 2278–2324.
Lee, T. S., & Mumford, D. (2003). Hierarchical Bayesian inference in the visual cortex.
Journal of the Optical Society of America, A, 20, 1434–1448.
Marks, T. K., & Movellan, J. R. (2001). Diffusion networks, product of experts, and
factor analysis. In T. W. Lee, T.-P. Jung, S. Makeig, & T. J. Sejnowski (Eds.), Proc.
Int. Conf. on Independent Component Analysis (pp. 481–485). San Diego.
Mayraz, G., & Hinton, G. E. (2001). Recognizing hand-written digits using hierarchical products of experts. IEEE Transactions on Pattern Analysis and Machine
Intelligence, 24, 189–197.
Neal, R. (1992). Connectionist learning of belief networks, Artificial Intelligence, 56,
71–113.
Neal, R. M., & Hinton, G. E. (1998). A new view of the EM algorithm that justifies
incremental, sparse and other variants. In M. I. Jordan (Ed.), Learning in graphical
models (pp. 355–368). Norwell, MA: Kluwer.
Ning, F., Delhomme, D., LeCun, Y., Piano, F., Bottou, L., & Barbano, P. (2005). Toward
automatic phenotyping of developing embryos from videos. IEEE Transactions on
Image Processing, 14(9), 1360–1371.
Roth, S., & Black, M. J. (2005). Fields of experts: A framework for learning image
priors. In IEEE Conf. on Computer Vision and Pattern Recognition (pp. 860–867).
Piscataway, NJ: IEEE.
Sanger, T. D. (1989). Optimal unsupervised learning in a single-layer linear feedforward neural networks. Neural Networks, 2(6), 459–473.
Simard, P. Y., Steinkraus, D., & Platt, J. (2003). Best practice for convolutional neural
networks applied to visual document analysis. In International Conference on Document Analysis and Recogntion (ICDAR) (pp. 958–962). Los Alamitos, CA: IEEE
Computer Society.
Teh, Y., & Hinton, G. E. (2001). Rate-coded restricted Boltzmann machines for face
recognition. In T. K. Leen, T. G. Dietterich, & V. Tresp (Eds.), Advances in neural
information processing systems, 13 (pp. 908–914). Cambridge, MA: MIT Press.
Teh, Y., Welling, M., Osindero, S., & Hinton, G. E. (2003). Energy-based models
for sparse overcomplete representations. Journal of Machine Learning Research, 4,
1235–1260.
Welling, M., Hinton, G., & Osindero, S. (2003). Learning sparse topographic representations with products of Student-t distributions. In S. Becker, S. Thrun,
& K. Obermayer (Eds.), Advances in neural information processing systems, 15
(pp. 1359–1366). Cambridge, MA: MIT Press.
Welling, M., Rosen-Zvi, M., & Hinton, G. E. (2005). Exponential family harmoniums with an application to information retrieval. In L. K. Saul, Y. Weiss, & L.
Bottou (Eds.), Advances in neural information processing systems, 17 (pp. 1481–1488).
Cambridge, MA: MIT Press.
Received June 8, 2005; accepted November 8, 2005.