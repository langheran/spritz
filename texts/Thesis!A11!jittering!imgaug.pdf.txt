imgaug Documentation
Release 0.2.5

Alexander Jung

Apr 05, 2018

Contents:

1

Installation

3

2

Examples: Basics
2.1 A standard use case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 A simple and common augmentation sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Heavy Augmentations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5
5
5
6

3

Examples: Keypoints
3.1 A simple example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11
11

4

Examples: Bounding Boxes
4.1 A simple example . . . . . . . . . . . . . . . . .
4.2 Dealing with bounding boxes outside of the image
4.3 Shifting/Moving Bounding Boxes . . . . . . . . .
4.4 Projection of BBs Onto Rescaled Images . . . . .
4.5 Computing Intersections, Unions and IoUs . . . .

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

13
13
14
17
17
19

Stochastic Parameters
5.1 Introduction . . . . . . . . . . . . .
5.2 Continuous Probability Distributions
5.3 Discrete Probability Distributions . .
5.4 Arithmetic . . . . . . . . . . . . . .
5.5 Special Parameters . . . . . . . . . .
5.6 Noise Parameters . . . . . . . . . . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

23
23
24
31
32
37
44

Blending/Overlaying images
6.1 Introduction . . . . . . .
6.2 Constant Alpha . . . . . .
6.3 SimplexNoiseAlpha . . .
6.4 FrequencyNoiseAlpha . .
6.5 IterativeNoiseAggregator
6.6 Sigmoid . . . . . . . . . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

45
45
46
48
52
55
56

Overview of Augmenters
7.1 Sequential . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2 SomeOf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3 OneOf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

59
59
60
62

5

6

7

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

i

7.4
7.5
7.6
7.7
7.8
7.9
7.10
7.11
7.12
7.13
7.14
7.15
7.16
7.17
7.18
7.19
7.20
7.21
7.22
7.23
7.24
7.25
7.26
7.27
7.28
7.29
7.30
7.31
7.32
7.33
7.34
7.35
7.36
7.37
7.38
7.39
8

ii

Sometimes . . . . . . .
WithColorspace . . . .
WithChannels . . . . .
Noop . . . . . . . . . .
Lambda . . . . . . . . .
AssertLambda . . . . .
AssertShape . . . . . .
Scale . . . . . . . . . .
CropAndPad . . . . . .
Pad . . . . . . . . . . .
Crop . . . . . . . . . .
Fliplr . . . . . . . . . .
Flipud . . . . . . . . . .
Superpixels . . . . . . .
ChangeColorspace . . .
Grayscale . . . . . . . .
GaussianBlur . . . . . .
AverageBlur . . . . . .
MedianBlur . . . . . . .
Convolve . . . . . . . .
Sharpen . . . . . . . . .
Emboss . . . . . . . . .
EdgeDetect . . . . . . .
DirectedEdgeDetect . .
Add . . . . . . . . . . .
AddElementwise . . . .
AdditiveGaussianNoise
Multiply . . . . . . . .
MultiplyElementwise .
Dropout . . . . . . . . .
CoarseDropout . . . . .
Invert . . . . . . . . . .
ContrastNormalization .
Affine . . . . . . . . . .
PiecewiseAffine . . . .
ElasticTransformation .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

. 62
. 64
. 65
. 66
. 66
. 66
. 67
. 67
. 68
. 71
. 71
. 71
. 71
. 72
. 74
. 74
. 74
. 75
. 75
. 80
. 80
. 81
. 82
. 82
. 83
. 83
. 83
. 87
. 87
. 90
. 90
. 95
. 95
. 96
. 99
. 101

imgaug
8.1 imgaug package . . . . . . . . .
8.1.1
Submodules . . . . . . .
8.1.2
imgaug . . . . . . . . .
8.1.3
parameters . . . . . . . .
8.1.4
augmenters.meta . . . .
8.1.5
augmenters.arithmetic .
8.1.6
augmenters.blur . . . . .
8.1.7
augmenters.color . . . .
8.1.8
augmenters.convolutional
8.1.9
augmenters.flip . . . . .
8.1.10 augmenters.geometric . .
8.1.11 augmenters.overlay . . .
8.1.12 augmenters.segmentation
8.1.13 augmenters.size . . . . .
8.1.14 Module contents . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

103
104
104
104
104
104
104
104
104
104
104
104
104
104
104
104

9

Indices and tables

105

iii

iv

imgaug Documentation, Release 0.2.5

imgaug is a library for image augmentation in machine learning experiments. It supports a wide range of augmentation
techniques, allows to easily combine these, has a simple yet powerful stochastic interface, can augment images and
keypoints/landmarks on these and offers augmentation in background processes for improved performance.

Fig. 1: Example augmentations of a single input image.

Contents:

1

imgaug Documentation, Release 0.2.5

2

Contents:

CHAPTER

1

Installation

The library uses python, which must be installed. Most development and testing is done in python 2.7. Python 3.x is
occasionally tested and seems to also work.
The following packages must be installed:
 numpy
 scipy
 scikit-image (pip install -U scikit-image)
 six (pip install -U six)
 OpenCV (i.e. cv2 must be available in python). The library is mainly tested in OpenCV 2, but seems to also
work in OpenCV 3.
When executing the installer, these packages will be automatically installed/upgraded where needed. This is not the
case for OpenCV, which must be installed manually.
Once the packages are available, imgaug can be installed using the following command:
pip install git+https://github.com/aleju/imgaug

This installs the latest version directly from github. If any error pops up, try adding sudo in front (i.e. sudo pip
install git+https://github.com/aleju/imgaug).
Alternatively, you can install the latest version which was added to pypi via pip install imgaug. That version
can sometimes be behind the version on github.
In rare cases, one might prefer to install from the locally cloned repository. This is possible using python
setup.py sdist && sudo pip install dist/imgaug-VERSION.tar.gz, where VERSION must
be replaced by the current version of the library (e.g. imgaug-0.2.5.tar.gz). The current version can be
derived from setup.py's content.
To deinstall the library use pip uninstall imgaug.

3

imgaug Documentation, Release 0.2.5

4

Chapter 1. Installation

CHAPTER

2

Examples: Basics

2.1 A standard use case
The following example shows a standard use case. An augmentation sequence (crop + horizontal flips + gaussian blur)
is defined once at the start of the script. Then many batches are loaded and augmented before being used for training.
from imgaug import augmenters as iaa
seq = iaa.Sequential([
iaa.Crop(px=(0, 16)), # crop images from each side by 0 to 16px (randomly chosen)
iaa.Fliplr(0.5), # horizontally flip 50% of the images
iaa.GaussianBlur(sigma=(0, 3.0)) # blur images with a sigma of 0 to 3.0
])
for batch_idx in range(1000):
# 'images' should be either a 4D numpy array of shape (N, height, width, channels)
# or a list of 3D numpy arrays, each having shape (height, width, channels).
# Grayscale images must have shape (height, width, 1) each.
# All images must have numpy's dtype uint8. Values are expected to be in
# range 0-255.
images = load_batch(batch_idx)
images_aug = seq.augment_images(images)
train_on_images(images_aug)

2.2 A simple and common augmentation sequence
The following example shows an augmentation sequence that might be useful for many common experiments. It
applies crops and affine transformations to images, flips some of the images horizontally, adds a bit of noise and blur
and also changes the contrast as well as brightness.
import imgaug as ia
from imgaug import augmenters as iaa

5

imgaug Documentation, Release 0.2.5

import numpy as np
ia.seed(1)
# Example batch of images.
# The array has shape (32, 64, 64, 3) and dtype uint8.
images = np.array(
[ia.quokka(size=(64, 64)) for _ in range(32)],
dtype=np.uint8
)
seq = iaa.Sequential([
iaa.Fliplr(0.5), # horizontal flips
iaa.Crop(percent=(0, 0.1)), # random crops
# Small gaussian blur with random sigma between 0 and 0.5.
# But we only blur about 50% of all images.
iaa.Sometimes(0.5,
iaa.GaussianBlur(sigma=(0, 0.5))
),
# Strengthen or weaken the contrast in each image.
iaa.ContrastNormalization((0.75, 1.5)),
# Add gaussian noise.
# For 50% of all images, we sample the noise once per pixel.
# For the other 50% of all images, we sample the noise per pixel AND
# channel. This can change the color (not only brightness) of the
# pixels.
iaa.AdditiveGaussianNoise(loc=0, scale=(0.0, 0.05*255), per_channel=0.5),
# Make some images brighter and some darker.
# In 20% of all cases, we sample the multiplier once per channel,
# which can end up changing the color of the images.
iaa.Multiply((0.8, 1.2), per_channel=0.2),
# Apply affine transformations to each image.
# Scale/zoom them, translate/move them, rotate them and shear them.
iaa.Affine(
scale={"x": (0.8, 1.2), "y": (0.8, 1.2)},
translate_percent={"x": (-0.2, 0.2), "y": (-0.2, 0.2)},
rotate=(-25, 25),
shear=(-8, 8)
)
], random_order=True) # apply augmenters in random order
images_aug = seq.augment_images(images)

2.3 Heavy Augmentations
The following example shows a large augmentation sequence containing many different augmenters, leading to significant changes in the augmented images. Depending on the use case, the sequence might be too strong. Occasionally it can also break images by changing them too much. To weaken the effects you can lower the value of
iaa.SomeOf((0, 5), ...) to e.g. (0, 3) or decrease the probability of some augmenters to be applied by
decreasing in sometimes = lambda aug: iaa.Sometimes(0.5, aug) the value 0.5 to e.g. 0.3.
import imgaug as ia
from imgaug import augmenters as iaa
import numpy as np

6

Chapter 2. Examples: Basics

imgaug Documentation, Release 0.2.5

Fig. 2.1: Example results of the above simple augmentation sequence.

ia.seed(1)
# Example batch of images.
# The array has shape (32, 64, 64, 3) and dtype uint8.
images = np.array(
[ia.quokka(size=(64, 64)) for _ in range(32)],
dtype=np.uint8
)
# Sometimes(0.5, ...) applies the given augmenter in 50% of all cases,
# e.g. Sometimes(0.5, GaussianBlur(0.3)) would blur roughly every second
# image.
sometimes = lambda aug: iaa.Sometimes(0.5, aug)
# Define our sequence of augmentation steps that will be applied to every image.
seq = iaa.Sequential(
[
#
# Apply the following augmenters to most images.
#
iaa.Fliplr(0.5), # horizontally flip 50% of all images
iaa.Flipud(0.2), # vertically flip 20% of all images
# crop some of the images by 0-10% of their height/width
sometimes(iaa.Crop(percent=(0, 0.1))),
#
#
#
#
#
#
#

Apply affine transformations to some of the images
- scale to 80-120% of image height/width (each axis independently)
- translate by -20 to +20 relative to height/width (per axis)
- rotate by -45 to +45 degrees
- shear by -16 to +16 degrees
- order: use nearest neighbour or bilinear interpolation (fast)
- mode: use any available mode to fill newly created pixels

2.3. Heavy Augmentations

7

imgaug Documentation, Release 0.2.5

#
see API or scikit-image for which modes are available
# - cval: if the mode is constant, then use a random brightness
#
for the newly created pixels (e.g. sometimes black,
#
sometimes white)
sometimes(iaa.Affine(
scale={"x": (0.8, 1.2), "y": (0.8, 1.2)},
translate_percent={"x": (-0.2, 0.2), "y": (-0.2, 0.2)},
rotate=(-45, 45),
shear=(-16, 16),
order=[0, 1],
cval=(0, 255),
mode=ia.ALL
)),
#
# Execute 0 to 5 of the following (less important) augmenters per
# image. Don't execute all of them, as that would often be way too
# strong.
#
iaa.SomeOf((0, 5),
[
# Convert some images into their superpixel representation,
# sample between 20 and 200 superpixels per image, but do
# not replace all superpixels with their average, only
# some of them (p_replace).
sometimes(
iaa.Superpixels(
p_replace=(0, 1.0),
n_segments=(20, 200)
)
),
# Blur each image with varying strength using
# gaussian blur (sigma between 0 and 3.0),
# average/uniform blur (kernel size between 2x2 and 7x7)
# median blur (kernel size between 3x3 and 11x11).
iaa.OneOf([
iaa.GaussianBlur((0, 3.0)),
iaa.AverageBlur(k=(2, 7)),
iaa.MedianBlur(k=(3, 11)),
]),
# Sharpen each image, overlay the result with the original
# image using an alpha between 0 (no sharpening) and 1
# (full sharpening effect).
iaa.Sharpen(alpha=(0, 1.0), lightness=(0.75, 1.5)),
# Same as sharpen, but for an embossing effect.
iaa.Emboss(alpha=(0, 1.0), strength=(0, 2.0)),
# Search in some images either for all edges or for
# directed edges. These edges are then marked in a black
# and white image and overlayed with the original image
# using an alpha of 0 to 0.7.
sometimes(iaa.OneOf([
iaa.EdgeDetect(alpha=(0, 0.7)),
iaa.DirectedEdgeDetect(
alpha=(0, 0.7), direction=(0.0, 1.0)

8

Chapter 2. Examples: Basics

imgaug Documentation, Release 0.2.5

),
])),
# Add gaussian noise to some images.
# In 50% of these cases, the noise is randomly sampled per
# channel and pixel.
# In the other 50% of all cases it is sampled once per
# pixel (i.e. brightness change).
iaa.AdditiveGaussianNoise(
loc=0, scale=(0.0, 0.05*255), per_channel=0.5
),
# Either drop randomly 1 to 10% of all pixels (i.e. set
# them to black) or drop them on an image with 2-5% percent
# of the original size, leading to large dropped
# rectangles.
iaa.OneOf([
iaa.Dropout((0.01, 0.1), per_channel=0.5),
iaa.CoarseDropout(
(0.03, 0.15), size_percent=(0.02, 0.05),
per_channel=0.2
),
]),
# Invert each image's chanell with 5% probability.
# This sets each pixel value v to 255-v.
iaa.Invert(0.05, per_channel=True), # invert color channels
# Add a value of -10 to 10 to each pixel.
iaa.Add((-10, 10), per_channel=0.5),
# Change brightness of images (50-150% of original value).
iaa.Multiply((0.5, 1.5), per_channel=0.5),
# Improve or worsen the contrast of images.
iaa.ContrastNormalization((0.5, 2.0), per_channel=0.5),
# Convert each image to grayscale and then overlay the
# result with the original with random alpha. I.e. remove
# colors with varying strengths.
iaa.Grayscale(alpha=(0.0, 1.0)),
# In some images move pixels locally around (with random
# strengths).
sometimes(
iaa.ElasticTransformation(alpha=(0.5, 3.5), sigma=0.25)
),
# In some images distort local areas with varying strength.
sometimes(iaa.PiecewiseAffine(scale=(0.01, 0.05)))
],
# do all of the above augmentations in random order
random_order=True
)
],
# do all of the above augmentations in random order
random_order=True
)

2.3. Heavy Augmentations

9

imgaug Documentation, Release 0.2.5

images_aug = seq.augment_images(images)

Fig. 2.2: Example results of the above heavy augmentation sequence.

10

Chapter 2. Examples: Basics

CHAPTER

3

Examples: Keypoints

imgaug can handle not only images, but also keypoints/landmarks on these. E.g. if an image is rotated during augmentation, the library can also rotate all landmarks correspondingly.

3.1 A simple example
The following example loads an image and places four keypoints on it. The image is then augmented to be brighter,
slightly rotated and scaled. These augmentations are also applied to the keypoints. The image is then shown before
and after augmentation (with keypoints drawn on it).
import imgaug as ia
from imgaug import augmenters as iaa
ia.seed(1)
image = ia.quokka(size=(256, 256))
keypoints = ia.KeypointsOnImage([
ia.Keypoint(x=65, y=100),
ia.Keypoint(x=75, y=200),
ia.Keypoint(x=100, y=100),
ia.Keypoint(x=200, y=80)
], shape=image.shape)
seq = iaa.Sequential([
iaa.Multiply((1.2, 1.5)), # change brightness, doesn't affect keypoints
iaa.Affine(
rotate=10,
scale=(0.5, 0.7)
) # rotate by exactly 10deg and scale to 50-70%, affects keypoints
])
# Make our sequence deterministic.
# We can now apply it to the image and then to the keypoints and it will

11

imgaug Documentation, Release 0.2.5

# lead to the same augmentations.
# IMPORTANT: Call this once PER BATCH, otherwise you will always get the
# exactly same augmentations for every batch!
seq_det = seq.to_deterministic()
# Augment keypoints and images.
# As we only have one image and list of keypoints, we use
# [image] and [keypoints] to turn both into lists (batches) for the
# functions and then [0] to reverse that. In a real experiment, your
# variables would likely already be lists.
image_aug = seq_det.augment_images([image])[0]
keypoints_aug = seq_det.augment_keypoints([keypoints])[0]
# print coordinates before/after augmentation (see below)
# use after.x_int and after.y_int to get rounded integer coordinates
for i in range(len(keypoints.keypoints)):
before = keypoints.keypoints[i]
after = keypoints_aug.keypoints[i]
print("Keypoint %d: (%.8f, %.8f) -> (%.8f, %.8f)" % (
i, before.x, before.y, after.x, after.y)
)
# image with keypoints before/after augmentation (shown below)
image_before = keypoints.draw_on_image(image, size=7)
image_after = keypoints_aug.draw_on_image(image_aug, size=7)

Console output of the example:
Keypoint
Keypoint
Keypoint
Keypoint

0:
1:
2:
3:

(65.00000000, 100.00000000) -> (94.11840007, 105.19555403)
(75.00000000, 200.00000000) -> (89.69884728, 164.11942850)
(100.00000000, 100.00000000) -> (114.38441167, 108.76899867)
(200.00000000, 80.00000000) -> (174.32927032, 107.39826243)

Fig. 3.1: Image with keypoints, before (left) and after (right) augmentation. Keypoints are shown in green and drawn
in after the augmentation process.

12

Chapter 3. Examples: Keypoints

CHAPTER

4

Examples: Bounding Boxes

imgaug offers support for bounding boxes (aka rectangles, regions of interest). E.g. if an image is rotated during
augmentation, the library can also rotate all bounding boxes on it correspondingly.
Features of the library's bounding box support:
 Represent bounding boxes as objects (imgaug.BoundingBox).
 Augment bounding boxes.
 Draw bounding boxes on images.
 Move/shift bounding boxes on images, project them onto other images (e.g. onto the same image after resizing),
compute their intersections/unions and IoU values.

4.1 A simple example
The following example loads an image and places two bounding boxes on it. The image is then augmented to be
brighter, slightly rotated and scaled. These augmentations are also applied to the bounding boxes. The image is then
shown before and after augmentation (with bounding boxes drawn on it).
import imgaug as ia
from imgaug import augmenters as iaa
ia.seed(1)
image = ia.quokka(size=(256, 256))
bbs = ia.BoundingBoxesOnImage([
ia.BoundingBox(x1=65, y1=100, x2=200, y2=150),
ia.BoundingBox(x1=150, y1=80, x2=200, y2=130)
], shape=image.shape)
seq = iaa.Sequential([
iaa.Multiply((1.2, 1.5)), # change brightness, doesn't affect BBs
iaa.Affine(

13

imgaug Documentation, Release 0.2.5

translate_px={"x": 40, "y": 60},
scale=(0.5, 0.7)
) # translate by 40/60px on x/y axis, and scale to 50-70%, affects BBs
])
# Make our sequence deterministic.
# We can now apply it to the image and then to the BBs and it will
# lead to the same augmentations.
# IMPORTANT: Call this once PER BATCH, otherwise you will always get the
# exactly same augmentations for every batch!
seq_det = seq.to_deterministic()
# Augment BBs and images.
# As we only have one image and list of BBs, we use
# [image] and [bbs] to turn both into lists (batches) for the
# functions and then [0] to reverse that. In a real experiment, your
# variables would likely already be lists.
image_aug = seq_det.augment_images([image])[0]
bbs_aug = seq_det.augment_bounding_boxes([bbs])[0]
# print coordinates before/after augmentation (see below)
# use .x1_int, .y_int, ... to get integer coordinates
for i in range(len(bbs.bounding_boxes)):
before = bbs.bounding_boxes[i]
after = bbs_aug.bounding_boxes[i]
print("BB %d: (%.4f, %.4f, %.4f, %.4f) -> (%.4f, %.4f, %.4f, %.4f)" % (
i,
before.x1, before.y1, before.x2, before.y2,
after.x1, after.y1, after.x2, after.y2)
)
# image with BBs before/after augmentation (shown below)
image_before = bbs.draw_on_image(image, thickness=2)
image_after = bbs_aug.draw_on_image(image_aug, thickness=2, color=[0, 0, 255])

Console output of the example:
BB 0: (65.0000, 100.0000, 200.0000, 150.0000) -> (130.7524, 171.3311, 210.1272, 200.
7291)
BB 1: (150.0000, 80.0000, 200.0000, 130.0000) -> (180.7291, 159.5718, 210.1272, 188.
9699)

Note that the bounding box augmentation works by augmenting each box's edge coordinates and then drawing a
bounding box around these augmented coordinates. Each of these new bounding boxes is therefore axis-aligned. This
can sometimes lead to oversized new bounding boxes, especially in the case of rotation. The following image shows
the result of the same code as in the example above, but Affine was replaced by Affine(rotate=45):

4.2 Dealing with bounding boxes outside of the image
When augmenting images and their respective bounding boxes, the boxes can end up fully or partially outside of the
image plane. By default, the library still returns these boxes, even though that may not be desired. The following
example shows how to (a) remove bounding boxes that are fully/partially outside of the image and (b) how to cut
bounding boxes that are partially outside of the image so that their are fully inside.

14

Chapter 4. Examples: Bounding Boxes

imgaug Documentation, Release 0.2.5

Fig. 4.1: Image with bounding boxes, before (left) and after (right) augmentation. Bounding boxes are shown in green
(before augmentation) and blue (after augmentation).

Fig. 4.2: Image with bounding boxes, before (left) and after (right) augmentation. The image was augmentated by
rotating it by 45 degrees. The axis-aligned bounding box around the augmented keypoints ends up being oversized.

4.2. Dealing with bounding boxes outside of the image

15

imgaug Documentation, Release 0.2.5

import imgaug as ia
from imgaug import augmenters as iaa
import numpy as np
ia.seed(1)
GREEN = [0, 255, 0]
ORANGE = [255, 140, 0]
RED = [255, 0, 0]
# Pad image with a 1px white and (BY-1)px black border
def pad(image, by):
if by <= 0:
return image
image_border1 = np.pad(
image, ((1, 1), (1, 1), (0, 0)),
mode="constant", constant_values=255
)
image_border2 = np.pad(
image_border1, ((by-1, by-1), (by-1, by-1), (0, 0)),
mode="constant", constant_values=0
)
return image_border2
# Draw BBs on an image
# and before doing that, extend the image plane by BORDER pixels.
# Mark BBs inside the image plane with green color, those partially inside
# with orange and those fully outside with red.
def draw_bbs(image, bbs, border):
image_border = pad(image, border)
for bb in bbs.bounding_boxes:
if bb.is_fully_within_image(image.shape):
color = GREEN
elif bb.is_partly_within_image(image.shape):
color = ORANGE
else:
color = RED
image_border = bb.shift(left=border, top=border)\
.draw_on_image(image_border, thickness=2, color=color)
return image_border
# Define example image with three small square BBs next to each other.
# Augment these BBs by shifting them to the right.
image = ia.quokka(size=(256, 256))
bbs = ia.BoundingBoxesOnImage([
ia.BoundingBox(x1=25, x2=75, y1=25, y2=75),
ia.BoundingBox(x1=100, x2=150, y1=25, y2=75),
ia.BoundingBox(x1=175, x2=225, y1=25, y2=75)
], shape=image.shape)
seq = iaa.Affine(translate_px={"x": 120})
seq_det = seq.to_deterministic()
image_aug = seq_det.augment_images([image])[0]
bbs_aug = seq_det.augment_bounding_boxes([bbs])[0]

16

Chapter 4. Examples: Bounding Boxes

imgaug Documentation, Release 0.2.5

# Draw the BBs (a) in their original form, (b) after augmentation,
# (c) after augmentation and removing those fully outside the image,
# (d) after augmentation and removing those fully outside the image and
# cutting those partially inside the image so that they are fully inside.
image_before = draw_bbs(image, bbs, 100)
image_after1 = draw_bbs(image_aug, bbs_aug, 100)
image_after2 = draw_bbs(image_aug, bbs_aug.remove_out_of_image(), 100)
image_after3 = draw_bbs(image_aug, bbs_aug.remove_out_of_image().cut_out_of_image(),
100)

4.3 Shifting/Moving Bounding Boxes
The function shift(top=<int>, right=<int>, bottom=<int>, left=<int>) can be used to change the x/y position of all
or specific bounding boxes.
import imgaug as ia
from imgaug import augmenters as iaa
ia.seed(1)
# Define image and two bounding boxes
image = ia.quokka(size=(256, 256))
bbs = ia.BoundingBoxesOnImage([
ia.BoundingBox(x1=25, x2=75, y1=25, y2=75),
ia.BoundingBox(x1=100, x2=150, y1=25, y2=75)
], shape=image.shape)
# Move both BBs 25px to the right and the second BB 25px down
bbs_shifted = bbs.shift(left=25)
bbs_shifted.bounding_boxes[1] = bbs_shifted.bounding_boxes[1].shift(top=25)
# Draw images before/after moving BBs
image = bbs.draw_on_image(image, color=[0, 255, 0], thickness=2, alpha=0.75)
image = bbs_shifted.draw_on_image(image, color=[0, 0, 255], thickness=2, alpha=0.75)

4.4 Projection of BBs Onto Rescaled Images
Bounding boxes can easily be projected onto rescaled versions of the same image using the function .on(image). This
changes the coordinates of the bounding boxes. E.g. if the top left coordinate of the bounding box was before at
x=10% and y=15%, it will still be at x/y 10%/15% on the new image, though the absolute pixel values will change
depending on the height/width of the new image.
import imgaug as ia
from imgaug import augmenters as iaa
ia.seed(1)
# Define image with two bounding boxes
image = ia.quokka(size=(256, 256))
bbs = ia.BoundingBoxesOnImage([
ia.BoundingBox(x1=25, x2=75, y1=25, y2=75),
ia.BoundingBox(x1=100, x2=150, y1=25, y2=75)

4.3. Shifting/Moving Bounding Boxes

17

imgaug Documentation, Release 0.2.5

18

Chapter 4. Examples: Bounding Boxes

imgaug Documentation, Release 0.2.5

Fig. 4.4: Using shift() to move bounding boxes around (green: original BBs, blue: shifted/moved BBs).

], shape=image.shape)
# Rescale image and bounding boxes
image_rescaled = ia.imresize_single_image(image, (512, 512))
bbs_rescaled = bbs.on(image_rescaled)
# Draw image before/after rescaling and with rescaled bounding boxes
image_bbs = bbs.draw_on_image(image, thickness=2)
image_rescaled_bbs = bbs_rescaled.draw_on_image(image_rescaled, thickness=2)

4.5 Computing Intersections, Unions and IoUs
Computing intersections, unions and especially IoU values (intersection over union) is common for many machine
learning experiments. The library offers easy functions for that.
import imgaug as ia
from imgaug import augmenters as iaa
import numpy as np
ia.seed(1)
# Define image with two bounding boxes.
image = ia.quokka(size=(256, 256))
bb1 = ia.BoundingBox(x1=50, x2=100, y1=25, y2=75)
bb2 = ia.BoundingBox(x1=75, x2=125, y1=50, y2=100)
# Compute intersection, union and IoU value
# Intersection and union are both bounding boxes. They are here

4.5. Computing Intersections, Unions and IoUs

19

imgaug Documentation, Release 0.2.5

Fig. 4.5: Using on() to project bounding boxes from one image to the other, here onto an image of 2x the original size.
New coordinates are determined based on their relative positions on the old image.

# decreased/increased in size purely for better visualization.
bb_inters = bb1.intersection(bb2).extend(all_sides=-1)
bb_union = bb1.union(bb2).extend(all_sides=2)
iou = bb1.iou(bb2)
# Draw bounding boxes, intersection, union and IoU value on image.
image_bbs = np.copy(image)
image_bbs = bb1.draw_on_image(image_bbs, thickness=2, color=[0, 255, 0])
image_bbs = bb2.draw_on_image(image_bbs, thickness=2, color=[0, 255, 0])
image_bbs = bb_inters.draw_on_image(image_bbs, thickness=2, color=[255, 0, 0])
image_bbs = bb_union.draw_on_image(image_bbs, thickness=2, color=[0, 0, 255])
image_bbs = ia.draw_text(
image_bbs, text="IoU=%.2f" % (iou,),
x=bb_union.x2+10, y=bb_union.y1+bb_union.height//2,
color=[255, 255, 255], size=13
)

20

Chapter 4. Examples: Bounding Boxes

imgaug Documentation, Release 0.2.5

Fig. 4.6: Two bounding boxes on an image (green), their intersection (red, slightly shrunk), their union (blue, slightly
extended) and their IoU value (white).

4.5. Computing Intersections, Unions and IoUs

21

imgaug Documentation, Release 0.2.5

22

Chapter 4. Examples: Bounding Boxes

CHAPTER

5

Stochastic Parameters

5.1 Introduction
When augmenting images during experiments, usually one wants to augment each image in different ways. E.g. when
rotating images, not every image is supposed to be rotated by 10 degrees. Instead, only some are supposed to be
rotated by 10 degrees, while others should be rotated by 17 degrees or 5 degrees or -12 degrees - and so on. This can
be achieved using random functions, but reimplementing these, making sure that they generate the expected values
and getting them to work with determinism is cumbersome. To avoid all of this work, the library uses Stochastic
Parameters. These are usually abstract representations of probability distributions, e.g. the normal distribution N(0,
1.0) or the uniform range [0.0, 10.0]. Basically all augmenters accept these stochastic parameters, making it easy to
control value ranges. They are all adapted to work with determinism out of the box.
The below code shows their usage:
from imgaug import augmenters as iaa
from imgaug import parameters as iap
seq = iaa.Sequential([
iaa.GaussianBlur(
sigma=iap.Uniform(0.0, 1.0)
),
iaa.ContrastNormalization(
iap.Choice(
[1.0, 1.5, 3.0],
p=[0.5, 0.3, 0.2]
)
),
iaa.Affine(
rotate=iap.Normal(0.0, 30),
translate_px=iap.RandomSign(iap.Poisson(3))
),
iaa.AddElementwise(
iap.Discretize(
(iap.Beta(0.5, 0.5) * 2 - 1.0) * 64

23

imgaug Documentation, Release 0.2.5

)
),
iaa.Multiply(
iap.Positive(iap.Normal(0.0, 0.1)) + 1.0
)
])

The example does the following:
 Blur each image by sigma, where sigma is sampled from the uniform range [0.0, 1.0). Example values:
0.053, 0.414, 0.389, 0.277, 0.981.
 Increase the contrast either to 100% (50% chance of being chosen) or by 150% (30% chance of being
chosen) or 300% (20% chance of being chosen).
 Rotate each image by a random amount of degrees, where the degree is sampled from the normal distribution N(0, 30). Most of the values will be in the range -60 to 60.
 Translate each image by n pixels, where n is sampled from a poisson distribution with alpha=3 (pick should
be around x=3). As we cant translate by a fraction of a pixel, we pick a discrete distribution here, which
poisson is. However, we do not just want to translate towards the right/top (only positive values). So we
randomly flip the sign sometimes to get negative pixel amounts too.
 Add to each pixel a random value, sampled from the beta distribution Beta(0.5, 0.5). This distribution has
its peaks around 0.0 and 1.0. We multiply this with 2 and subtract 1 to get it into the range [-1, 1]. Then we
multiply by 64 to get the range [-64, 64]. As we beta distribution is continuous, we convert it to a discrete
distribution. The result is that a lot of pixel intensities are shifted by -64 or 64 (or a value very close to
these two). Some other pixel intensities are kept (mostly) at their old values.
 We use Multiply to make each image brighter. The brightness increase is sampled from a normal distribution, converted to have only positive values. So most values are expected to be in the range 0.0 to 0.2. We
add 1.0 to set the brightness to 1.0 (100%) to 1.2 (120%).

5.2 Continuous Probability Distributions
The following continuous probability distributions are available:
 Normal(loc, scale): The popular normal distribution with mean loc and standard deviation scale. Example:
from imgaug import parameters as iap
params = [
iap.Normal(0, 1),
iap.Normal(5, 3),
iap.Normal(iap.Choice([-3, 3]), 1),
iap.Normal(iap.Uniform(-3, 3), 1)
]
iap.show_distributions_grid(params)

 Laplace(loc, scale): Similarly shaped to a normal distribution. Has its peak at loc and width scale. Example:
from imgaug import parameters as iap
params = [
iap.Laplace(0, 1),
iap.Laplace(5, 3),
iap.Laplace(iap.Choice([-3, 3]), 1),
iap.Laplace(iap.Uniform(-3, 3), 1)

24

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

5.2. Continuous Probability Distributions

25

imgaug Documentation, Release 0.2.5

26

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

]
iap.show_distributions_grid(params)

 ChiSquare(df): The chi-square ("X^2") distribution with df degrees of freedom. Roughly similar to a continuous version of the poisson distribution. Has its peak at df and no negative values, only positive ones.
Example:
from imgaug import parameters as iap
params = [
iap.ChiSquare(1),
iap.ChiSquare(3),
iap.ChiSquare(iap.Choice([1, 5])),
iap.RandomSign(iap.ChiSquare(3))
]

5.2. Continuous Probability Distributions

27

imgaug Documentation, Release 0.2.5

iap.show_distributions_grid(params)

 Weibull(a): Weibull distribution with shape a. Example:
from imgaug import parameters as iap
params = [
iap.Weibull(0.5),
iap.Weibull(1),
iap.Weibull(1.5),
iap.Weibull((0.5, 1.5))
]
iap.show_distributions_grid(params)

 Uniform(a, b): Uniform distribution in the range [a, b). Example:

28

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

5.2. Continuous Probability Distributions

29

imgaug Documentation, Release 0.2.5

from imgaug import parameters as iap
params = [
iap.Uniform(0, 1),
iap.Uniform(iap.Normal(-3, 1), iap.Normal(3, 1)),
iap.Uniform([-1, 0], 1),
iap.Uniform((-1, 0), 1)
]
iap.show_distributions_grid(params)

 Beta(alpha, beta): Beta distribution with parameters alpha and beta. Example:
from imgaug import parameters as iap
params = [
iap.Beta(0.5, 0.5),

30

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

iap.Beta(2.0, 2.0),
iap.Beta(1.0, 0.5),
iap.Beta(0.5, 1.0)
]
iap.show_distributions_grid(params)

5.3 Discrete Probability Distributions
The following discrete probability distributions are available:
 Binomial(p): The common binomial distribution with probability p. Useful to simulate coinflips. Example:

5.3. Discrete Probability Distributions

31

imgaug Documentation, Release 0.2.5

from imgaug import parameters as iap
params = [
iap.Binomial(0.5),
iap.Binomial(0.9)
]
iap.show_distributions_grid(params)

 DiscreteUniform(a, b): The discrete uniform distribution in the range [a..b]. Example:
from imgaug import parameters as iap
params = [
iap.DiscreteUniform(0, 10),
iap.DiscreteUniform(-10, 10),
iap.DiscreteUniform([-10, -9, -8, -7], 10),
iap.DiscreteUniform((-10, -7), 10)
]
iap.show_distributions_grid(params)

 Poisson(lam): Poisson distribution with shape lam. Generates no negative values. Example:
from imgaug import parameters as iap
params = [
iap.Poisson(1),
iap.Poisson(2.5),
iap.Poisson((1, 2.5)),
iap.RandomSign(iap.Poisson(2.5))
]
iap.show_distributions_grid(params)

5.4 Arithmetic
The library supports arithmetic operations on stochastic parameters. This allows to modify values sampled from
distributions or combine several distributions with each other.
32

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

5.4. Arithmetic

33

imgaug Documentation, Release 0.2.5

34

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

 Add(param, val, elementwise): Add val to the values sampled from param. The shortcut is +, e.g. Uniform(. . . )
+ 1. val can be a stochastic parameter itself. Usually, only one value is sampled from val per sampling run and
added to all samples generated by param. Alternatively, elementwise can be set to True in order to generate as
many samples from val as from param and add them elementwise. Note that Add merely adds to the results of
param and does not combine probability density functions (see e.g. example image 3 and 4). Example:
from imgaug import parameters as iap
params = [
iap.Uniform(0, 1) + 1, # identical to: Add(Uniform(0, 1), 1)
iap.Add(iap.Uniform(0, 1), iap.Choice([0, 1], p=[0.7, 0.3])),
iap.Normal(0, 1) + iap.Uniform(-5.5, -5) + iap.Uniform(5, 5.5),
iap.Normal(0, 1) + iap.Uniform(-7, 5) + iap.Poisson(3),
iap.Add(iap.Normal(-3, 1), iap.Normal(3, 1)),
iap.Add(iap.Normal(-3, 1), iap.Normal(3, 1), elementwise=True)
]
iap.show_distributions_grid(
params,
rows=2,
sample_sizes=[ # (iterations, samples per iteration)
(1000, 1000), (1000, 1000), (1000, 1000),
(1000, 1000), (1, 100000), (1, 100000)
]
)

 Subtract(param, val, elementwise): Same as Add, but subtracts val from the results of param. The shortcut is -,
e.g. Uniform(. . . ) - 1.
 Multiply(param, val, elementwise): Same as Add, but multiplies val with the results of param. The shortcut is
*, e.g. Uniform(. . . ) * 2. Example:
5.4. Arithmetic

35

imgaug Documentation, Release 0.2.5

from imgaug import parameters as iap
params = [
iap.Uniform(0, 1) * 2, # identical to: Multiply(Uniform(0, 1), 2)
iap.Multiply(iap.Uniform(0, 1), iap.Choice([0, 1], p=[0.7, 0.3])),
(iap.Normal(0, 1) * iap.Uniform(-5.5, -5)) * iap.Uniform(5, 5.5),
(iap.Normal(0, 1) * iap.Uniform(-7, 5)) * iap.Poisson(3),
iap.Multiply(iap.Normal(-3, 1), iap.Normal(3, 1)),
iap.Multiply(iap.Normal(-3, 1), iap.Normal(3, 1), elementwise=True)
]
iap.show_distributions_grid(
params,
rows=2,
sample_sizes=[ # (iterations, samples per iteration)
(1000, 1000), (1000, 1000), (1000, 1000),
(1000, 1000), (1, 100000), (1, 100000)
]
)

 Divide(param, val, elementwise): Same as Multiply, but divides by val. The shortcut is /, e.g. Uniform(. . . ) / 2.
Division by zero is automatically prevented (zeros are replaced by ones). Example:
from imgaug import parameters as iap
params = [
iap.Uniform(0, 1) / 2, # identical to: Divide(Uniform(0, 1), 2)
iap.Divide(iap.Uniform(0, 1), iap.Choice([0, 2], p=[0.7, 0.3])),
(iap.Normal(0, 1) / iap.Uniform(-5.5, -5)) / iap.Uniform(5, 5.5),
(iap.Normal(0, 1) * iap.Uniform(-7, 5)) / iap.Poisson(3),
iap.Divide(iap.Normal(-3, 1), iap.Normal(3, 1)),

36

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

iap.Divide(iap.Normal(-3, 1), iap.Normal(3, 1), elementwise=True)
]
iap.show_distributions_grid(
params,
rows=2,
sample_sizes=[ # (iterations, samples per iteration)
(1000, 1000), (1000, 1000), (1000, 1000),
(1000, 1000), (1, 100000), (1, 100000)
]
)

 Power(param, val, elementwise): Same as Add, but raises sampled values to the exponent val. The shortcut is
**. Example:
from imgaug import parameters as iap
params = [
iap.Uniform(0, 1) ** 2, # identical to: Power(Uniform(0, 1), 2)
iap.Clip(iap.Uniform(-1, 1) ** iap.Normal(0, 1), -4, 4)
]
iap.show_distributions_grid(params, rows=1)

5.5 Special Parameters
 Deterministic(v): A constant. Upon sampling, this always returns v.
 Choice(values, replace=True, p=None): Upon sampling, this parameter picks randomly elements from a list
5.5. Special Parameters

37

imgaug Documentation, Release 0.2.5

values. If replace is set to True (default), the picking happens with replacement. By default, all elements have
the same probability of being picked. This can be modified using p. Note that values may also contain strings
and other stochastic parameters. In the latter case, each picked parameter will be replaced by a sample from
that parameter. This allows merging of probability mass functions, but is a rather slow process. All elements in
values should have the same datatype (except for stochastic parameters). Example:
from imgaug import parameters as iap
params = [
iap.Choice([0, 1, 2]),
iap.Choice([0, 1, 2], p=[0.15, 0.5, 0.35]),
iap.Choice([iap.Normal(-3, 1), iap.Normal(3, 1)]),
iap.Choice([iap.Normal(-3, 1), iap.Poisson(3)])
]
iap.show_distributions_grid(params)

 Clip(param, minval=None, maxval=None): Clips the values sampled from param to the range [minval, maxval].
minval and maxval may be None. In that case, only minimum or maximum clipping is applied (depending on
what is None). Example:
from imgaug import parameters as iap
params = [
iap.Clip(iap.Normal(0, 1), -2, 2),
iap.Clip(iap.Normal(0, 1), -2, None)
]
iap.show_distributions_grid(params, rows=1)

 Discretize(param): Converts a continuous parameter param into a discrete one (using rounding). Discrete
parameters are not changed. Example:
from imgaug import parameters as iap
params = [
iap.Discretize(iap.Normal(0, 1)),
iap.Discretize(iap.ChiSquare(3))
]
iap.show_distributions_grid(params, rows=1)

38

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

5.5. Special Parameters

39

imgaug Documentation, Release 0.2.5

40

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

 Absolute(param): Applies an absolute function to each value sampled from param, turning them to positive
ones. Example:
from imgaug import parameters as iap
params = [
iap.Absolute(iap.Normal(0, 1)),
iap.Absolute(iap.Laplace(0, 1))
]
iap.show_distributions_grid(params, rows=1)

 RandomSign(param, p_positive=0.5): Randomly flips the signs of values sampled from param. Optionally, the
probability of flipping a value's sign towards positive can be set. Example:
from imgaug import parameters as iap
params = [
iap.ChiSquare(3),
iap.RandomSign(iap.ChiSquare(3)),
iap.RandomSign(iap.ChiSquare(3), p_positive=0.75),
iap.RandomSign(iap.ChiSquare(3), p_positive=0.9)
]
iap.show_distributions_grid(params)

 ForceSign(param, positive, mode="invert", reroll_count_max=2): Converts all values sampled from param
to positive or negative ones. Signs of positive/negative values may simply be flipped (mode="invert") or resampled from param (mode="reroll"). When rerolling, the number of iterations is limited to reroll_count_max
(afterwards mode="invert" is used). Example:
from imgaug import parameters as iap
params = [
iap.ForceSign(iap.Normal(0, 1), positive=True),
iap.ChiSquare(3) - 3.0,
iap.ForceSign(iap.ChiSquare(3) - 3.0, positive=True, mode="invert"),
iap.ForceSign(iap.ChiSquare(3) - 3.0, positive=True, mode="reroll")
]
iap.show_distributions_grid(params)

5.5. Special Parameters

41

imgaug Documentation, Release 0.2.5

42

Chapter 5. Stochastic Parameters

imgaug Documentation, Release 0.2.5

5.5. Special Parameters

43

imgaug Documentation, Release 0.2.5

 Positive(other_param, mode="invert", reroll_count_max=2): Shortcut for ForceSign with positive=True. E.g.
Positive(Normal(0, 1)) restricts a normal distribution to only positive values.
 Negative(other_param, mode="invert", reroll_count_max=2): Shortcut for ForceSign with positive=False.
E.g. Negative(Normal(0, 1)) restricts a normal distribution to only negative values.
 FromLowerResolution(other_param, size_percent=None, size_px=None, method="nearest", min_size=1): Intended for 2d-sampling processes, e.g. for masks. Samples these in a lower resolution space. E.g. instead of
sampling a mask at 100x100, this allows to sample it at 10x10 and then upsample to 100x100. One advantage is,
that this can be faster. Another possible use is, that the upsampling may result in large, correlated blobs (linear
interpolation) or rectangles (nearest neighbour interpolation).

5.6 Noise Parameters
TODO

44

Chapter 5. Stochastic Parameters

CHAPTER

6

Blending/Overlaying images

6.1 Introduction
Most augmenters in the library affect images in uniform ways per image. Sometimes one might not want that and
instead desires more localized effects (e.g. change the color of some image regions, while keeping the others unchanged) or wants to keep a fraction of the old image (e.g. blur the image and mix in a bit of the unblurred image).
Alpha-based augmenters are intended for these use cases. They either mix two images using a constant alpha factor or
using a pixel-wise mask. Below image shows examples.
# First row
iaa.Alpha(
(0.0, 1.0),
first=iaa.MedianBlur(11),
per_channel=True
)
# Second row
iaa.SimplexNoiseAlpha(
first=iaa.EdgeDetect(1.0),
per_channel=False
)
# Third row
iaa.SimplexNoiseAlpha(
first=iaa.EdgeDetect(1.0),
second=iaa.ContrastNormalization((0.5, 2.0)),
per_channel=0.5
)
# Forth row
iaa.FrequencyNoiseAlpha(
first=iaa.Affine(
rotate=(-10, 10),
translate_px={"x": (-4, 4), "y": (-4, 4)}

45

imgaug Documentation, Release 0.2.5

),
second=iaa.AddToHueAndSaturation((-40, 40)),
per_channel=0.5
)
# Fifth row
iaa.SimplexNoiseAlpha(
first=iaa.SimplexNoiseAlpha(
first=iaa.EdgeDetect(1.0),
second=iaa.ContrastNormalization((0.5, 2.0)),
per_channel=True
),
second=iaa.FrequencyNoiseAlpha(
exponent=(-2.5, -1.0),
first=iaa.Affine(
rotate=(-10, 10),
translate_px={"x": (-4, 4), "y": (-4, 4)}
),
second=iaa.AddToHueAndSaturation((-40, 40)),
per_channel=True
),
per_channel=True,
aggregation_method="max",
sigmoid=False
)

6.2 Constant Alpha
The augmenter Alpha allows to mix the results of two image sources using an alpha factor that is constant throughout
the whole image, i.e. it follows roughly I_blend = alpha * I_a + (1 - alpha) * I_b per image, where I_a is the image
from the first image source and I_b is the image from the second image source. Often, the first source will be an
augmented version of the image and the second source will be the original image, leading to a blend of augmented and
unaugmented image. The second image source can also be an augmented version of the image, leading to a blend of
two distinct augmentation effects. Alpha is already built into some augmenters as a parameter, e.g. into EdgeDetect.
The below example code generates images that are a blend between Sharpen and CoarseDropout. Notice how the
sharpening does not affect the black rectangles from dropout, as the two augmenters are both applied to the original
images and merely blended.
import imgaug as ia
from imgaug import augmenters as iaa
ia.seed(1)
# Example batch of images.
# The array has shape (8, 128, 128, 3) and dtype uint8.
images = np.array(
[ia.quokka(size=(128, 128)) for _ in range(8)],
dtype=np.uint8
)
seq = iaa.Alpha(
factor=(0.2, 0.8),
first=iaa.Sharpen(1.0, lightness=2),
second=iaa.CoarseDropout(p=0.1, size_px=8)

46

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

Fig. 6.1: Various effects of combining alpha-augmenters with other augmenters. First row shows Alpha with MedianBlur, second SimplexNoiseAlpha with EdgeDetect, third SimplexNoiseAlpha with EdgeDetect and ContrastNormalization, third shows FrequencyNoiseAlpha with Affine and AddToHueAndSaturation and forth row shows a mixture
SimplexNoiseAlpha and FrequencyNoiseAlpha.

6.2. Constant Alpha

47

imgaug Documentation, Release 0.2.5

)
images_aug = seq.augment_images(images)

Fig. 6.2: Mixing Sharpen and CoarseDropout via Alpha - not the same as executing them one after the other.
Similar to other augmenters, Alpha supports a per_channel mode, in which it samples overlay strengths for each
channel independently. As a result, some channels may show more from the first (or second) image source than other
channels. This can lead to visible color effects. The following example is the same as the one above, only per_channel
was activated.
iaa.Alpha(..., per_channel=True)

Alpha can also be used with augmenters that change the position of pixels, leading to "ghost" images. (This should
not be done when also augmenting keypoints, as their position becomes unclear.)
seq = iaa.Alpha(
factor=(0.2, 0.8),
first=iaa.Affine(rotate=(-20, 20)),
per_channel=True
)

6.3 SimplexNoiseAlpha
Alpha uses a constant blending factor per image (or per channel). This limits the possibilities. Often a more localized
factor is desired to create unusual patterns. SimplexNoiseAlpha is an augmenter that does that. It generates continuous
masks following simplex noise and uses them to perform local blending. The following example shows a combination
of SimplexNoiseAlpha and Multiply (with per_channel=True) that creates blobs of various colors in the image.
import imgaug as ia
from imgaug import augmenters as iaa

48

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

Fig. 6.3: Mixing Sharpen and CoarseDropout via Alpha and per_channel set to True.

Fig. 6.4: Mixing original images with their rotated version. Some channels are more visibly rotated than others.

6.3. SimplexNoiseAlpha

49

imgaug Documentation, Release 0.2.5

ia.seed(1)
# Example batch of images.
# The array has shape (8, 128, 128, 3) and dtype uint8.
images = np.array(
[ia.quokka(size=(128, 128)) for _ in range(8)],
dtype=np.uint8
)
seq = iaa.SimplexNoiseAlpha(
first=iaa.Multiply(iap.Choice([0.5, 1.5]), per_channel=True)
)
images_aug = seq.augment_images(images)

Fig. 6.5: Mixing original images with their versions modified by Multiply (with per_channel set to True). Simplex
noise masks are used for the blending process, leading to blobby patterns.
SimplexNoiseAlpha also supports per_channel=True, leading to unique noise masks sampled per channel. The following example shows the combination of SimplexNoiseAlpha (with per_channel=True) and EdgeDetect. Even though
EdgeDetect usually generates black and white images (white=edges, black=everything else), here the combination
leads to strong color effects as the channel-wise noise masks only blend EdgeDetect's result for some channels.
seq = iaa.SimplexNoiseAlpha(
first=iaa.EdgeDetect(1.0),
per_channel=True
)

SimplexNoiseAlpha uses continuous noise masks (2d arrays with values in the range [0.0, 1.0]) to blend images. The
below image shows examples of 64x64 noise masks generated by SimplexNoiseAlpha with default settings. Values
close to 1.0 (white) indicate that pixel colors will be taken from the first image source, while 0.0 (black) values indicate
that pixel colors will be taken from the second image source. (Often only one image source will be given in the form
of augmenters and the second will fall back to the original images fed into SimplexNoiseAlpha.)
SimplexNoiseAlpha generates its noise masks in low resolution images and then upscales the masks to the size of the
50

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

Fig. 6.6: Blending images via simplex noise can lead to unexpected but diverse patterns when per_channel is set to
True. Here, a mixture of original images with EdgeDetect(1.0) is used.

Fig. 6.7: Examples of noise masks generated by SimplexNoiseAlpha using default settings.

6.3. SimplexNoiseAlpha

51

imgaug Documentation, Release 0.2.5

input images. During upscaling it usually uses nearest neighbour interpolation (nearest), linear interpolation (linear)
or cubic interpolation (cubic). Nearest neighbour interpolation leads to noise maps with rectangular blobs. The below
example shows noise maps generated when only using nearest neighbour interpolation.
seq = iaa.SimplexNoiseAlpha(
...,
upscale_method="nearest"
)

Fig. 6.8: Examples of noise masks generated by SimplexNoiseAlpha when restricting the upscaling method to nearest.
Similarly, the following example shows noise maps generated when only using linear interpolation.
seq = iaa.SimplexNoiseAlpha(
...,
upscale_method="linear"
)

Fig. 6.9: Examples of noise masks generated by SimplexNoiseAlpha when restricting the upscaling method to linear.

6.4 FrequencyNoiseAlpha
FrequencyNoiseAlpha is mostly identical to SimplexNoiseAlpha. In contrast to SimplexNoiseAlpha it uses a different
sampling process to generate the noise maps. The process is based on starting with random frequencies, weighting
them with a random exponent and then transforming from frequency domain to spatial domain. When using a low
exponent value this leads to large, smooth blobs. Slightly higher exponents lead to cloudy patterns. High exponent
values lead to recurring, small patterns. The below example shows the usage of FrequencyNoiseAlpha.
import imgaug as ia
from imgaug import augmenters as iaa
from imgaug import parameters as iap
ia.seed(1)
# Example batch of images.
# The array has shape (8, 64, 64, 3) and dtype uint8.
images = np.array(
[ia.quokka(size=(128, 128)) for _ in range(8)],
dtype=np.uint8
)
seq = iaa.FrequencyNoiseAlpha(
first=iaa.Multiply(iap.Choice([0.5, 1.5]), per_channel=True)
)
images_aug = seq.augment_images(images)

52

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

Fig. 6.10: Mixing original images with their versions modified by Multiply (with per_channel set to True). Simplex
noise masks are used for the blending process, leading to blobby patterns.
Similarly to simplex noise, FrequencyNoiseAlpha also supports per_channel=True, leading to different noise maps
per image channel.
seq = iaa.FrequencyNoiseAlpha(
first=iaa.EdgeDetect(1.0),
per_channel=True
)

The below image shows random example noise masks generated by FrequencyNoiseAlpha with default settings.
The following image shows the effects of varying exponent between -4.0 and 4.0. To show these effects more clearly,
a few features of FrequencyNoiseAlpha were deactivated (e.g. multiple iterations). In the code, E is the value of the
exponent (e.g. E=-2.0).
seq = iaa.FrequencyNoiseAlpha(
exponent=E,
first=iaa.Multiply(iap.Choice([0.5, 1.5]), per_channel=True),
size_px_max=32,
upscale_method="linear",
iterations=1,
sigmoid=False
)

Similarly to SimplexNoiseAlpha, FrequencyNoiseAlpha also generates the noise masks as low resolution versions and
then upscales them to the full image size. The following images show the usage of nearest neighbour interpolation
(upscale_method="nearest") and linear interpolation (upscale_method="linear").

6.4. FrequencyNoiseAlpha

53

imgaug Documentation, Release 0.2.5

Fig. 6.11: Blending images via frequency noise can lead to unexpected but diverse patterns when per_channel is set to
True. Here, a mixture of original images with EdgeDetect(1.0) is used.

Fig. 6.12: Examples of noise masks generated by FrequencyNoiseAlpha using default settings.

Fig. 6.13: Examples of noise masks generated by FrequencyNoiseAlpha using default settings with varying exponents.

54

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

Fig. 6.14: Examples of noise masks generated by FrequencyNoiseAlpha when restricting the upscaling method to
nearest.

Fig. 6.15: Examples of noise masks generated by FrequencyNoiseAlpha when restricting the upscaling method to
linear.

6.5 IterativeNoiseAggregator
Both SimplexNoiseAlpha and FrequencyNoiseAlpha wrap around IterativeNoiseAggregator, a component to generate
noise masks in multiple iterations. It has parameters for the number of iterations (1 to N) and for the aggregation
methods, which controls how the noise masks from the different iterations are to be combined. Valid aggregation
methods are "min", "avg" and "max", where min takes the minimum over all iteration's masks, max the maxmimum
and avg the average. As a result, masks generated with method min tend to be close to 0.0 (mostly black values),
those generated with max close to 1.0 and avg converges towards 0.5. (0.0 means that the results of the second image
dominate the final image, so in many cases the original images before the augmenter). The following image shows the
effects of changing the number of iterations when combining FrequencyNoise with IterativeNoiseAggregator.
# This is how the iterations would be changed for FrequencyNoiseAlpha.
# (Same for `SimplexNoiseAlpha`.)
seq = iaa.FrequencyNoiseAlpha(
...,
iterations=N
)

The following image shows the effects of changing the aggregation mode (with varying iterations).
# This is how the iterations and aggregation method would be changed for
# FrequencyNoiseAlpha. (Same for `SimplexNoiseAlpha`.)
seq = iaa.FrequencyNoiseAlpha(
...,
iterations=N,
aggregation_method=M
)

6.5. IterativeNoiseAggregator

55

imgaug Documentation, Release 0.2.5

Fig. 6.16: Examples of varying the number of iterations in IterativeNoiseAggregator (here in combination with FrequencyNoise).

Fig. 6.17: Examples of varying the methods and iterations in IterativeNoiseAggregator (here in combination with
FrequencyNoise).

6.6 Sigmoid
Generated noise masks can often end up having many values around 0.5, especially when running IterativeNoiseAggregator with many iterations and aggregation method avg. This can be undesired. Sigmoid is a method to compensate
that. It applies a sigmoid function to the noise masks, forcing the values to mostly lie close to 0.0 or 1.0 and only
rarely in between. This can lead to blobs of values close to 1.0 ("use only colors from images coming from source
A"), surrounded by blobs with values close to 0.0 ("use only colors from images coming from source B"). This is
similar to taking either from one image source (per pixel) or the other, but usually not both. Sigmoid is integrated into
both SimplexNoiseAlpha and FrequencyNoiseAlpha. It can be dynamically activated/deactivated and has a threshold
parameter that controls how aggressive and pushes the noise values towards 1.0.
# This is how the Sigmoid would be activated/deactivated for
# FrequencyNoiseAlpha (same for SimplexNoiseAlpha). P is the probability
# of the Sigmoid being activated (can be True/False), T is the

56

Chapter 6. Blending/Overlaying images

imgaug Documentation, Release 0.2.5

# threshold (sane values are usually around -10 to +10, can be a
# tuple, e.g. sigmoid_thresh=(-10, 10), to indicate a uniform range).
seq = iaa.FrequencyNoiseAlpha(
...,
sigmoid=P,
sigmoid_thresh=T
)

The below image shows the effects of applying Sigmoid to noise masks generated by FrequencyNoise.

Fig. 6.18: Examples of noise maps without and with activated Sigmoid (noise maps here from FrequencyNoise).
The below image shows the effects of varying the sigmoid's threshold. Lower values place the threshold further to the
"left" (lower x values), leading to more x-values being above the threshold values, leading to more 1.0s in the noise
masks.

Fig. 6.19: Examples of varying the Sigmoid threshold from -10.0 to 10.0.

6.6. Sigmoid

57

imgaug Documentation, Release 0.2.5

58

Chapter 6. Blending/Overlaying images

CHAPTER

7

Overview of Augmenters

7.1 Sequential
List augmenter that may contain other augmenters to apply in sequence or random order.
Apply in predefined order:
aug = iaa.Sequential([
iaa.Affine(translate_px={"x":-40}),
iaa.AdditiveGaussianNoise(scale=0.1*255)
])

59

imgaug Documentation, Release 0.2.5

Apply in random order (note that the order is sampled once per batch and then the same for all images within the
batch):
aug = iaa.Sequential([
iaa.Affine(translate_px={"x":-40}),
iaa.AdditiveGaussianNoise(scale=0.1*255)
], random_order=True)

7.2 SomeOf
List augmenter that applies only some of its children to images.
Apply two of four given augmenters:
aug = iaa.SomeOf(2, [
iaa.Affine(rotate=45),
iaa.AdditiveGaussianNoise(scale=0.2*255),
iaa.Add(50, per_channel=True),
iaa.Sharpen(alpha=0.5)
])

Apply 0 to <max> given augmenters (where <max> is automatically replaced with the number of children):
aug = iaa.SomeOf((0, None), [
iaa.Affine(rotate=45),
iaa.AdditiveGaussianNoise(scale=0.2*255),
iaa.Add(50, per_channel=True),
iaa.Sharpen(alpha=0.5)
])

Pick two of four given augmenters and apply them in random order:

60

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.2. SomeOf

61

imgaug Documentation, Release 0.2.5

aug = iaa.SomeOf(2, [
iaa.Affine(rotate=45),
iaa.AdditiveGaussianNoise(scale=0.2*255),
iaa.Add(50, per_channel=True),
iaa.Sharpen(alpha=0.5)
], random_order=True)

7.3 OneOf
Augmenter that always executes exactly one of its children.
Apply one of four augmenters to each image:
aug = iaa.OneOf([
iaa.Affine(rotate=45),
iaa.AdditiveGaussianNoise(scale=0.2*255),
iaa.Add(50, per_channel=True),
iaa.Sharpen(alpha=0.5)
])

7.4 Sometimes
Augment only p percent of all images with one or more augmenters.
Apply gaussian blur to about 50% of all images:
aug = iaa.Sometimes(0.5, iaa.GaussianBlur(sigma=2.0))

Apply gaussian blur to about 50% of all images. Apply a mixture of affine rotations and sharpening to the other 50%.

62

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.4. Sometimes

63

imgaug Documentation, Release 0.2.5

aug = iaa.Sometimes(
0.5,
iaa.GaussianBlur(sigma=2.0),
iaa.Sequential([iaa.Affine(rotate=45), iaa.Sharpen(alpha=1.0)])
)

7.5 WithColorspace
Apply child augmenters within a specific colorspace.
Convert images to HSV, then increase each pixels H-value by 10 to 50:
aug = iaa.WithColorspace(
to_colorspace="HSV",
from_colorspace="RGB",
children=iaa.WithChannels(0, iaa.Add((10, 50)))
)

64

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.6 WithChannels
Apply child augmenters to specific channels.
Increase each pixel's R-value (redness) by 10 to 100:
aug = iaa.WithChannels(0, iaa.Add((10, 100)))

Rotate each image's red channel by 0 to 45 degrees:
aug = iaa.WithChannels(0, iaa.Affine(rotate=(0, 45)))

7.6. WithChannels

65

imgaug Documentation, Release 0.2.5

7.7 Noop
Augmenter that never changes input images ("no operation").
aug = iaa.Noop()

7.8 Lambda
Augmenter that calls a lambda function for each batch of input image.
Replace in every image each fourth row with black pixels:
def img_func(images, random_state, parents, hooks):
for img in images:
img[::4] = 0
return images
def keypoint_func(keypoints_on_images, random_state, parents, hooks):
return keypoints_on_images
aug = iaa.Lambda(img_func, keypoint_func)

7.9 AssertLambda
Augmenter that runs an assert on each batch of input images using a lambda function as condition.
TODO examples

66

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.10 AssertShape
Augmenter to make assumptions about the shape of input image(s) and keypoints.
Check if each image in a batch has shape 32x32x3, otherwise raise an exception:
seq = iaa.Sequential([
iaa.AssertShape((None, 32, 32, 3)),
iaa.Fliplr(0.5) # only executed if shape matches
])

Check if each image in a batch has a height in the range 32<=x<64, a width of exactly 64 and either 1 or 3 channels:
seq = iaa.Sequential([
iaa.AssertShape((None, (32, 64), 32, [1, 3])),
iaa.Fliplr(0.5)
])

7.11 Scale
Augmenter that scales/resizes images to specified heights and widths.
Scale each image to height=32 and width=64:
aug = iaa.Scale({"height": 32, "width": 64})

7.10. AssertShape

67

imgaug Documentation, Release 0.2.5

Scale each image to height=32 and keep the aspect ratio for width the same:
aug = iaa.Scale({"height": 32, "width": "keep-aspect-ratio"})

Scale each image to something between 50 and 100% of its original size:
aug = iaa.Scale((0.5, 1.0))

Scale each image's height to 50-75% of its original size and width to either 16px or 32px or 64px:
aug = iaa.Scale({"height": (0.5, 0.75), "width": [16, 32, 64]})

7.12 CropAndPad
Augmenter that crops/pads images by defined amounts in pixels or percent (relative to input image size).
NOTE: This augmenter automatically resizes images back to their original size after it has augmented them. To
deactivate this, add the parameter keep_size=False.
Crop or pad each side by up to 10 percent relative to its original size (negative values result in cropping, positive in
padding):
aug = iaa.CropAndPad(percent=(-0.25, 0.25))

Pad each side by 0 to 20 percent. This adds new pixels to the sides. These pixels will either be filled with a constant
value (mode=constant) or filled with the value on the closest edge (mode=edge). If a constant value is used, it will be
a random value between 0 and 128 (sampled per image).
68

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.12. CropAndPad

69

imgaug Documentation, Release 0.2.5

aug = iaa.CropAndPad(
percent=(0, 0.2),
pad_mode=["constant", "edge"],
pad_cval=(0, 128)
)

Pad the top side of each image by 0 to 30 pixels, the right side by 0-10px, bottom side by 0-30px and left side by 010px. Use any of the available modes to fill new pixels and if the mode is constant then use a constant value between
0 and 128.
aug = iaa.CropAndPad(
px=((0, 30), (0, 10), (0, 30), (0, 10)),
pad_mode=ia.ALL,
pad_cval=(0, 128)
)

Crop/pad each side by up to 10px. The value will be sampled once per image and used for all sides (i.e. all sides
gain/lose the same number of rows/colums).
aug = iaa.CropAndPad(
px=(-10, 10),
sample_independently=False
)

70

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.13 Pad
Augmenter that pads images, i.e. adds columns/rows to them.
This is a proxy for CropAndPad. It only accepts positive pixel/percent values.

7.14 Crop
Augmenter that crops/cuts away pixels at the sides of the image.
This is a proxy for CropAndPad. It only accepts positive pixel/percent values and transfers them as negative values to
CropAndPad.

7.15 Fliplr
Flip/mirror input images horizontally.
Flip 50% of all images horizontally:
aug = iaa.Fliplr(0.5)

7.16 Flipud
Flip/mirror input images vertically.
Flip 50% of all images vertically:

7.13. Pad

71

imgaug Documentation, Release 0.2.5

aug = iaa.Flipud(0.5)

7.17 Superpixels
Completely or partially transform images to their superpixel representation.
Generate about 64 superpixels per image. Replace each one with a probability of 50% by its average pixel color.
aug = iaa.Superpixels(p_replace=0.5, n_segments=64)

Generate 16 to 128 superpixels per image. Replace each superpixel with a probability between 10 and 100% (sampled
once per image) by its average pixel color.
aug = iaa.Superpixels(p_replace=(0.1, 1.0), n_segments=(16, 128))

Effect of setting n_segments to a fixed value of 64 and then increasing p_replace from 0.0 and 1.0:
Effect of setting p_replace to a fixed value of 1.0 and then increasing n_segments from 1*16 to 9*16=144:

72

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.17. Superpixels

73

imgaug Documentation, Release 0.2.5

7.18 ChangeColorspace
Augmenter to change the colorspace of images.
The following example shows how to change the colorspace from RGB to HSV, then add 50-100 to the first channel,
then convert back to RGB. This increases the hue value of each image.
aug = iaa.Sequential([
iaa.ChangeColorspace(from_colorspace="RGB", to_colorspace="HSV"),
iaa.WithChannels(0, iaa.Add((50, 100))),
iaa.ChangeColorspace(from_colorspace="HSV", to_colorspace="RGB")
])

7.19 Grayscale
Augmenter to convert images to their grayscale versions.
Change images to grayscale and overlay them with the original image by varying strengths, effectively removing 0 to
100% of the color:
aug = iaa.Grayscale(alpha=(0.0, 1.0))

Visualization of increasing alpha from 0.0 to 1.0 in 8 steps:

7.20 GaussianBlur
Augmenter to blur images using gaussian kernels.
Blur each image with a gaussian kernel with a sigma of 3.0:

74

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

aug = iaa.GaussianBlur(sigma=(0.0, 3.0))

7.21 AverageBlur
Blur an image by computing simple means over neighbourhoods.
Blur each image using a mean over neihbourhoods that have a random size between 2x2 and 11x11:
aug = iaa.AverageBlur(k=(2, 11))

Blur each image using a mean over neihbourhoods that have random sizes, which can vary between 5 and 11 in height
and 1 and 3 in width:
aug = iaa.AverageBlur(k=((5, 11), (1, 3)))

7.22 MedianBlur
Blur an image by computing median values over neighbourhoods.
Blur each image using a median over neihbourhoods that have a random size between 3x3 and 11x11:
aug = iaa.MedianBlur(k=(3, 11))

7.21. AverageBlur

75

imgaug Documentation, Release 0.2.5

76

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.22. MedianBlur

77

imgaug Documentation, Release 0.2.5

78

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.22. MedianBlur

79

imgaug Documentation, Release 0.2.5

7.23 Convolve
Apply a Convolution to input images.
Convolve each image with a 3x3 kernel:
matrix = np.array([[0, -1, 0],
[-1, 4, -1],
[0, -1, 0]])
aug = iaa.Convolve(matrix=matrix)

Convolve each image with a 3x3 kernel, which is chosen dynamically per image:
def gen_matrix(image, nb_channels, random_state):
matrix_A = np.array([[0, -1, 0],
[-1, 4, -1],
[0, -1, 0]])
matrix_B = np.array([[0, 0, 0],
[0, -4, 1],
[0, 2, 1]])
if random_state.rand() < 0.5:
return [matrix_A] * nb_channels
else:
return [matrix_B] * nb_channels
aug = iaa.Convolve(matrix=gen_matrix)

7.24 Sharpen
Augmenter that sharpens images and overlays the result with the original image.
Sharpen an image, then overlay the results with the original using an alpha between 0.0 and 1.0:

80

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

aug = iaa.Sharpen(alpha=(0.0, 1.0), lightness=(0.75, 2.0))

Effects of keeping lightness fixed at 1.0 and then varying alpha between 0.0 and 1.0 in 8 steps:

Effects of keeping alpha fixed at 1.0 and then varying lightness between 0.75 and 1.5 in 8 steps:

7.25 Emboss
Augmenter that embosses images and overlays the result with the original image.
Emboss an image, then overlay the results with the original using an alpha between 0.0 and 1.0:
aug = iaa.Emboss(alpha=(0.0, 1.0), strength=(0.5, 1.5))

7.25. Emboss

81

imgaug Documentation, Release 0.2.5

Effects of keeping strength fixed at 1.0 and then varying alpha between 0.0 and 1.0 in 8 steps:
Effects of keeping alpha fixed at 1.0 and then varying strength between 0.5 and 1.5 in 8 steps:

7.26 EdgeDetect
Augmenter that detects all edges in images, marks them in a black and white image and then overlays the result with
the original image.
Detect edges in images, turning them into black and white images and then overlay these with the original images
using random alphas between 0.0 and 1.0:
aug = iaa.EdgeDetect(alpha=(0.0, 1.0))

Effect of increasing alpha from 0.0 to 1.0 in 8 steps:

7.27 DirectedEdgeDetect
Augmenter that detects edges that have certain directions and marks them in a black and white image and then overlays
the result with the original image.
Detect edges having random directions (0 to 360 degrees) in images, turning the images into black and white versions
and then overlay these with the original images using random alphas between 0.0 and 1.0:
aug = iaa.DirectedEdgeDetect(alpha=(0.0, 1.0), direction=(0.0, 1.0))

Effect of fixing direction to 0.0 and then increasing alpha from 0.0 to 1.0 in 8 steps:
Effect of fixing alpha to 1.0 and then increasing direction from 0.0 to 1.0 (0 to 360 degrees) in 8 steps:

82

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.28 Add
Add a value to all pixels in an image.
Add random values between -40 and 40 to images, with each value being sampled once per image and then being the
same for all pixels:
aug = iaa.Add((-40, 40))

Add random values between -40 and 40 to images. In 50% of all images the values differ per channel (3 sampled
value). In the other 50% of all images the value is the same for all channels:
aug = iaa.Add((-40, 40), per_channel=0.5)

7.29 AddElementwise
Add values to the pixels of images with possibly different values for neighbouring pixels.
Add random values between -40 and 40 to images, with each value being sampled per pixel:
aug = iaa.AddElementwise((-40, 40))

Add random values between -40 and 40 to images. In 50% of all images the values differ per channel (3 sampled
values per pixel). In the other 50% of all images the value is the same for all channels per pixel:
aug = iaa.AddElementwise((-40, 40), per_channel=0.5)

7.30 AdditiveGaussianNoise
Add gaussian noise (aka white noise) to images.

7.28. Add

83

imgaug Documentation, Release 0.2.5

84

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.30. AdditiveGaussianNoise

85

imgaug Documentation, Release 0.2.5

86

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

Add gaussian noise to an image, sampled once per pixel from a normal distribution N(0, s), where s is sampled
per image and varies between 0 and 0.05*255:
aug = iaa.AdditiveGaussianNoise(scale=(0, 0.05*255))

Add gaussian noise to an image, sampled once per pixel from a normal distribution N(0, 0.05*255):
aug = iaa.AdditiveGaussianNoise(scale=0.05*255)

Add gaussian noise to an image, sampled once per pixel from a normal distribution N(0, 0.05*255) for 50% of
all images and sampled three times (channel-wise) for the other 50% from the same normal distribution:
aug = iaa.AdditiveGaussianNoise(scale=0.05*255, per_channel=0.5)

7.31 Multiply
Multiply all pixels in an image with a specific value, thereby making the image darker or brighter.
Multiply each image with a random value between 0.5 and 1.5:
aug = iaa.Multiply((0.5, 1.5))

Multiply 50% of all images with a random value between 0.5 and 1.5 and multiply the remaining 50% channel-wise,
i.e. sample one multiplier independently per channel:
aug = iaa.Multiply((0.5, 1.5), per_channel=0.5)

7.32 MultiplyElementwise
Multiply values of pixels with possibly different values for neighbouring pixels, making each pixel darker or brighter.

7.31. Multiply

87

imgaug Documentation, Release 0.2.5

88

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.32. MultiplyElementwise

89

imgaug Documentation, Release 0.2.5

Multiply each pixel with a random value between 0.5 and 1.5:
aug = iaa.MultiplyElementwise((0.5, 1.5))

Multiply in 50% of all images each pixel with random values between 0.5 and 1.5 and multiply in the remaining 50%
of all images the pixels channel-wise, i.e. sample one multiplier independently per channel and pixel:
aug = iaa.MultiplyElementwise((0.5, 1.5), per_channel=0.5)

7.33 Dropout
Augmenter that sets a certain fraction of pixels in images to zero.
Sample per image a value p from the range 0<=p<=0.2 and then drop p percent of all pixels in the image (i.e. convert
them to black pixels):
aug = iaa.Dropout(p=(0, 0.2))

Sample per image a value p from the range 0<=p<=0.2 and then drop p percent of all pixels in the image (i.e. convert
them to black pixels), but do this independently per channel in 50% of all images:
aug = iaa.Dropout(p=(0, 0.2), per_channel=0.5)

7.34 CoarseDropout
Augmenter that sets rectangular areas within images to zero.
Drop 2% of all pixels by converting them to black pixels, but do that on a lower-resolution version of the image that
has 50% of the original size, leading to 2x2 squares being dropped:
aug = iaa.CoarseDropout(0.02, size_percent=0.5)

Drop 0 to 5% of all pixels by converting them to black pixels, but do that on a lower-resolution version of the image
that has 5% to 50% of the original size, leading to large rectangular areas being dropped:
aug = iaa.CoarseDropout((0.0, 0.05), size_percent=(0.02, 0.25))

Drop 2% of all pixels by converting them to black pixels, but do that on a lower-resolution version of the image that
has 50% of the original size, leading to 2x2 squares being dropped. Also do this in 50% of all images channel-wise,
so that only the information of some channels in set to 0 while others remain untouched:

90

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.34. CoarseDropout

91

imgaug Documentation, Release 0.2.5

92

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.34. CoarseDropout

93

imgaug Documentation, Release 0.2.5

94

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

aug = iaa.CoarseDropout(0.02, size_percent=0.15, per_channel=0.5)

7.35 Invert
Augmenter that inverts all values in images, i.e. sets a pixel from value v to 255-v.
Invert in 50% of all images all pixels:
aug = iaa.Invert(0.5)

For 50% of all images, invert all pixels in these images with 25% probability (per image). In the remaining 50% of all
images, invert 25% of all channels:
aug = iaa.Invert(0.25, per_channel=0.5)

7.36 ContrastNormalization
Augmenter that changes the contrast of images.

7.35. Invert

95

imgaug Documentation, Release 0.2.5

Normalize contrast by a factor of 0.5 to 1.5, sampled randomly per image:
aug = iaa.ContrastNormalization((0.5, 1.5))

Normalize contrast by a factor of 0.5 to 1.5, sampled randomly per image and for 50% of all images also independently
per channel:
aug = iaa.ContrastNormalization((0.5, 1.5), per_channel=0.5)

7.37 Affine
Augmenter to apply affine transformations to images.
Scale images to a value of 50 to 150% of their original size:
aug = iaa.Affine(scale=(0.5, 1.5))

Scale images to a value of 50 to 150% of their original size, but do this independently per axis (i.e. sample two values
per image):

96

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

aug = iaa.Affine(scale={"x": (0.5, 1.5), "y": (0.5, 1.5)})

Translate images by -20 to +20% on x- and y-axis independently:
aug = iaa.Affine(translate_percent={"x": (-0.2, 0.2), "y": (-0.2, 0.2)})

Translate images by -20 to 20 pixels on x- and y-axis independently:
aug = iaa.Affine(translate_px={"x": (-20, 20), "y": (-20, 20)})

Rotate images by -45 to 45 degrees:
aug = iaa.Affine(rotate=(-45, 45))

Shear images by -16 to 16 degrees:
aug = iaa.Affine(shear=(-16, 16))

When applying affine transformations, new pixels are often generated, e.g. when translating to the left, pixels are
generated on the right. Various modes exist to set how these pixels are ought to be filled. Below code shows an

7.37. Affine

97

imgaug Documentation, Release 0.2.5

98

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

example that uses all modes, sampled randomly per image. If the mode is constant (fill all with one constant value),
then a random brightness between 0 and 255 is used:
aug = iaa.Affine(translate_percent={"x": -0.20}, mode=ia.ALL, cval=(0, 255))

7.38 PiecewiseAffine
Augmenter that places a regular grid of points on an image and randomly moves the neighbourhood of these point
around via affine transformations. This leads to local distortions.
Distort images locally by moving points around, each with a distance v (percent relative to image size), where v is
sampled per point from N(0, z) z is sampled per image from the range 0.01 to 0.05:
aug = iaa.PiecewiseAffine(scale=(0.01, 0.05))

Effect of increasing scale from 0.01 to 0.3 in 8 steps:
PiecewiseAffine works by placing a regular grid of points on the image and moving them around. By default this grid
consists of 4x4 points. The below image shows the effect of increasing that value from 2x2 to 16x16 in 8 steps:

7.38. PiecewiseAffine

99

imgaug Documentation, Release 0.2.5

100

Chapter 7. Overview of Augmenters

imgaug Documentation, Release 0.2.5

7.39 ElasticTransformation
Augmenter to transform images by moving pixels locally around using displacement fields.
Distort images locally by moving individual pixels around following a distortions field with strength 0.25. The strength
of the movement is sampled per pixel from the range 0 to 5.0:
aug = iaa.ElasticTransformation(alpha=(0, 5.0), sigma=0.25)

Effect of keeping sigma fixed at 0.25 and increasing alpha from 0 to 5.0 in 8 steps:

Effect of keeping alpha fixed at 2.5 and increasing sigma from 0.01 to 1.0 in 8 steps:

7.39. ElasticTransformation

101

imgaug Documentation, Release 0.2.5

102

Chapter 7. Overview of Augmenters

103

imgaug Documentation, Release 0.2.5

CHAPTER

8

imgaug

8.1 imgaug package
8.1.1 Submodules
8.1.2 imgaug
8.1.3 parameters
8.1.4 augmenters.meta
8.1.5 augmenters.arithmetic
8.1.6 augmenters.blur
8.1.7 augmenters.color
8.1.8 augmenters.convolutional
8.1.9 augmenters.flip
8.1.10 augmenters.geometric
8.1.11 augmenters.overlay
8.1.12 augmenters.segmentation
8.1.13 augmenters.size
8.1.14 Module contents
See
104modindex for API.

Chapter 8. imgaug

CHAPTER

9

Indices and tables

 genindex
 modindex
 search

105

